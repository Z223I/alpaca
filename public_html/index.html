<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Sentinel - Real-time Stock Monitor</title>

    <!-- TradingView Lightweight Charts for professional candlestick charts -->
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --text-primary: #e4e4e4;
            --text-secondary: #a0a0a0;
            --accent-green: #4ecca3;
            --accent-red: #ff6b6b;
            --accent-blue: #4dabf7;
            --border-color: #2a2a3e;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Header */
        .header {
            background-color: var(--bg-secondary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--accent-green);
        }

        /* Search Bar */
        .search-container {
            display: flex;
            align-items: center;
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            padding: 8px 15px;
            flex: 0 0 400px;
        }

        .search-container input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 16px;
            outline: none;
            flex: 1;
            padding: 5px;
            text-transform: uppercase;
        }

        .search-container input::placeholder {
            color: var(--text-secondary);
        }

        .search-icon {
            cursor: pointer;
            color: var(--accent-blue);
            font-size: 20px;
            margin-left: 10px;
        }

        .search-icon:hover {
            color: var(--accent-green);
        }

        /* Main Container */
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
        }

        /* Tab Bar */
        .tab-bar {
            background-color: var(--bg-secondary);
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 5px;
            overflow-x: auto;
            min-height: 50px;
        }

        .tab {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 5px 5px 0 0;
            padding: 10px 20px;
            cursor: pointer;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background-color 0.2s;
        }

        .tab:hover {
            background-color: var(--bg-primary);
        }

        .tab.active {
            background-color: var(--bg-primary);
            border-bottom: 2px solid var(--accent-green);
        }

        .tab-close {
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
        }

        .tab-close:hover {
            color: var(--accent-red);
        }

        /* Chart Container */
        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
            overflow: hidden;
        }

        .chart-panel {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
        }

        .chart-panel.active {
            display: flex;
        }

        /* Chart Controls */
        .chart-controls {
            background-color: var(--bg-secondary);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            color: var(--text-secondary);
            font-size: 14px;
            margin-right: 5px;
        }

        .control-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background-color: var(--accent-blue);
            color: white;
        }

        .control-btn.active {
            background-color: var(--accent-green);
            color: white;
            border-color: var(--accent-green);
        }

        .control-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        .control-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        /* Chart Display Area */
        .chart-display {
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
            display: flex;
            overflow: auto;  /* Enable scrolling to debug */
        }

        .chart-main {
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
            padding: 20px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .canvas-container {
            flex: 1;
            min-height: 0;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
        }

        .main-chart {
            flex: 3;
            width: 100%;
            min-height: 500px;
            background-color: #16213e;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
        }

        .volume-chart {
            flex: 1;
            width: 100%;
            min-height: 120px;
            background-color: #0f3460;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
        }

        /* Time and Sales Panel */
        .time-sales-panel {
            width: 300px;
            background-color: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .time-sales-header {
            background-color: var(--bg-tertiary);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .time-sales-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .trade-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .trade-item:hover {
            background-color: var(--bg-tertiary);
        }

        .trade-time {
            color: var(--text-secondary);
            font-size: 11px;
        }

        .trade-price {
            font-weight: 600;
        }

        .trade-price.up {
            color: var(--accent-green);
        }

        .trade-price.down {
            color: var(--accent-red);
        }

        .trade-size {
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Resize Handle */
        .resize-handle {
            width: 5px;
            background-color: var(--border-color);
            cursor: col-resize;
            position: relative;
        }

        .resize-handle:hover {
            background-color: var(--accent-blue);
        }

        /* Status Bar */
        .status-bar {
            background-color: var(--bg-secondary);
            padding: 8px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--accent-green);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }

        /* Loading Spinner */
        .loading {
            display: none;
            text-align: center;
            padding: 50px;
            color: var(--text-secondary);
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Watch List Panel */
        .watch-list-panel {
            width: 400px;
            min-width: 300px;
            max-width: 600px;
            background-color: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .watch-list-header {
            background-color: var(--bg-tertiary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .watch-list-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-green);
            margin: 0;
        }

        .watch-list-add-container {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
        }

        .watch-list-add-input {
            flex: 1;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            text-transform: uppercase;
        }

        .watch-list-add-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .watch-list-add-btn {
            background-color: var(--accent-green);
            border: none;
            color: var(--bg-primary);
            padding: 8px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .watch-list-add-btn:hover {
            background-color: #3dba8a;
        }

        .watch-list-table-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
        }

        .watch-list-table {
            width: 100%;
            border-collapse: collapse;
        }

        .watch-list-table thead {
            position: sticky;
            top: 0;
            background-color: var(--bg-tertiary);
            z-index: 10;
        }

        .watch-list-table th {
            padding: 12px 10px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-color);
            white-space: nowrap;
        }

        .watch-list-table th.source-col {
            text-align: center;
            width: 60px;
        }

        .watch-list-table th.del-col {
            text-align: center;
            width: 50px;
        }

        .watch-list-table tbody tr {
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .watch-list-table tbody tr:hover {
            background-color: var(--bg-tertiary);
        }

        .watch-list-table td {
            padding: 10px;
            font-size: 14px;
        }

        .watch-list-table td.symbol-cell {
            font-weight: 600;
            color: var(--accent-blue);
        }

        .watch-list-table td.source-cell {
            text-align: center;
            font-size: 16px;
        }

        .watch-list-table td.del-cell {
            text-align: center;
        }

        .source-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 0 2px;
        }

        .source-indicator.on {
            background-color: var(--accent-green);
        }

        .source-indicator.off {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
        }

        .delete-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s;
        }

        .delete-btn:hover {
            color: var(--accent-red);
        }

        .watch-list-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Welcome Message */
        .welcome-message {
            text-align: center;
            padding: 100px 50px;
            color: var(--text-secondary);
        }

        .welcome-message h2 {
            font-size: 36px;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .welcome-message p {
            font-size: 18px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>üìä Market Sentinel</h1>
        <div class="search-container">
            <input
                type="text"
                id="symbolSearch"
                placeholder="Enter stock symbol (e.g., AAPL, GOOGL, TSLA)"
                onkeypress="handleSearchKeypress(event)"
            />
            <span class="search-icon" onclick="handleSearch()">üîç</span>
        </div>
    </div>

    <!-- Tab Bar -->
    <div class="tab-bar" id="tabBar">
        <!-- Tabs will be added dynamically -->
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Watch List Panel -->
        <div class="watch-list-panel">
            <div class="watch-list-header">
                <h2>üìã Watch List</h2>
            </div>

            <!-- Add Symbol Section -->
            <div class="watch-list-add-container">
                <input
                    type="text"
                    id="watchListAddInput"
                    class="watch-list-add-input"
                    placeholder="Add symbol..."
                    onkeypress="handleWatchListKeypress(event)"
                />
                <button class="watch-list-add-btn" onclick="addSymbolToWatchList()">Add</button>
            </div>

            <!-- Symbol Table -->
            <div class="watch-list-table-container">
                <table class="watch-list-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th class="source-col" title="Oracle">üîÆ</th>
                            <th class="source-col" title="Manual">‚úèÔ∏è</th>
                            <th class="source-col" title="Top Gainers">üìà</th>
                            <th class="source-col" title="Volume Surge">üöÄ</th>
                            <th class="del-col">Del</th>
                        </tr>
                    </thead>
                    <tbody id="watchListBody">
                        <!-- Symbols will be populated here -->
                        <tr class="watch-list-empty">
                            <td colspan="6">Loading watch list...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="chart-container" id="chartContainer">
            <!-- Welcome Message (shown when no charts open) -->
            <div class="welcome-message" id="welcomeMessage">
                <h2>Welcome to Market Sentinel</h2>
                <p>Enter a stock symbol in the search bar above to begin monitoring real-time market data.</p>
                <p>Features include candlestick charts, EMAs, VWAP, MACD, volume analysis, and time & sales data.</p>
            </div>

            <!-- Chart panels will be added dynamically -->
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-indicator">
            <span class="status-dot"></span>
            <span id="statusText">Ready</span>
        </div>
        <div>
            <span id="updateTime">Last updated: Never</span>
        </div>
    </div>

    <script>
        // Global state
        const state = {
            charts: new Map(),
            activeChart: null,
            updateIntervals: new Map(),
            timeSalesIntervals: new Map(),
            tradeWebSocket: null,
            tradeBuffer: new Map(),  // Buffer for real-time trades
            wsReconnectAttempts: 0,
            wsMaxReconnectAttempts: 5
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Market Sentinel initialized');
            updateStatus('Ready', 'System initialized');
            initializeTradeWebSocket();

            // Auto-focus search bar on page load
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.focus();
            }
        });

        // Global keyboard handler - any keystroke focuses search bar
        document.addEventListener('keydown', (event) => {
            const searchInput = document.getElementById('symbolSearch');
            const activeElement = document.activeElement;

            // Don't interfere if user is already typing in the search box
            if (activeElement === searchInput) {
                return;
            }

            // Don't interfere with special keys (Ctrl, Alt, etc.) or function keys
            if (event.ctrlKey || event.altKey || event.metaKey || event.key.startsWith('F')) {
                return;
            }

            // Don't interfere with navigation keys when not in search
            const navigationKeys = ['Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
            if (navigationKeys.includes(event.key)) {
                return;
            }

            // For any other printable character, focus the search bar
            if (event.key.length === 1 || event.key === 'Backspace') {
                searchInput.focus();
                // If it's a backspace, let it work on the search field
                // If it's a character, it will be automatically added to the focused input
            }
        });

        // Initialize WebSocket connection for real-time trades
        function initializeTradeWebSocket() {
            const wsUrl = 'ws://localhost:8765';
            console.log('Connecting to trade stream:', wsUrl);
            updateStatus('Connecting', 'Connecting to real-time trade stream...');

            try {
                state.tradeWebSocket = new WebSocket(wsUrl);

                state.tradeWebSocket.onopen = () => {
                    console.log('‚úÖ WebSocket connected to trade stream');
                    updateStatus('Connected', 'Real-time trade stream active');
                    state.wsReconnectAttempts = 0;

                    // Resubscribe to all active symbols
                    state.charts.forEach((chartData, symbol) => {
                        subscribeToSymbol(symbol);
                    });
                };

                state.tradeWebSocket.onmessage = (event) => {
                    handleTradeMessage(event.data);
                };

                state.tradeWebSocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Error', 'Trade stream connection error');
                };

                state.tradeWebSocket.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateStatus('Disconnected', 'Trade stream disconnected');
                    state.tradeWebSocket = null;

                    // Attempt reconnection
                    if (state.wsReconnectAttempts < state.wsMaxReconnectAttempts) {
                        state.wsReconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, state.wsReconnectAttempts), 30000);
                        console.log(`Reconnecting in ${delay/1000}s (attempt ${state.wsReconnectAttempts}/${state.wsMaxReconnectAttempts})...`);
                        setTimeout(initializeTradeWebSocket, delay);
                    } else {
                        console.error('Max reconnection attempts reached. Please refresh the page.');
                        updateStatus('Error', 'Trade stream unavailable. Please refresh page.');
                    }
                };

                // Keep-alive ping every 30 seconds
                setInterval(() => {
                    if (state.tradeWebSocket && state.tradeWebSocket.readyState === WebSocket.OPEN) {
                        state.tradeWebSocket.send(JSON.stringify({ action: 'ping' }));
                    }
                }, 30000);

            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                updateStatus('Error', 'Failed to connect to trade stream');
            }
        }

        // Subscribe to real-time trades for a symbol
        function subscribeToSymbol(symbol) {
            if (!state.tradeWebSocket || state.tradeWebSocket.readyState !== WebSocket.OPEN) {
                console.warn('WebSocket not ready, cannot subscribe to', symbol);
                return;
            }

            console.log('Subscribing to real-time trades for', symbol);
            state.tradeWebSocket.send(JSON.stringify({
                action: 'subscribe',
                symbol: symbol
            }));

            // Initialize trade buffer for this symbol
            if (!state.tradeBuffer.has(symbol)) {
                state.tradeBuffer.set(symbol, []);
            }
        }

        // Unsubscribe from real-time trades for a symbol
        function unsubscribeFromSymbol(symbol) {
            if (!state.tradeWebSocket || state.tradeWebSocket.readyState !== WebSocket.OPEN) {
                return;
            }

            console.log('Unsubscribing from real-time trades for', symbol);
            state.tradeWebSocket.send(JSON.stringify({
                action: 'unsubscribe',
                symbol: symbol
            }));

            // Clear trade buffer
            state.tradeBuffer.delete(symbol);
        }

        // Handle incoming WebSocket trade messages
        function handleTradeMessage(message) {
            try {
                const data = JSON.parse(message);

                if (data.type === 'trade') {
                    handleRealTimeTrade(data.symbol, data.data);
                } else if (data.type === 'subscribed') {
                    console.log('‚úÖ Subscribed to', data.symbol);
                } else if (data.type === 'unsubscribed') {
                    console.log('Unsubscribed from', data.symbol);
                } else if (data.type === 'pong') {
                    // Keep-alive response
                }
            } catch (error) {
                console.error('Error handling trade message:', error);
            }
        }

        // Handle a real-time trade update
        function handleRealTimeTrade(symbol, tradeData) {
            console.log(`Real-time trade for ${symbol}:`, tradeData);

            // Add to buffer
            const buffer = state.tradeBuffer.get(symbol) || [];
            buffer.unshift(tradeData);  // Add to front (newest first)

            // Keep only last 100 trades in buffer
            if (buffer.length > 100) {
                buffer.pop();
            }
            state.tradeBuffer.set(symbol, buffer);

            // Update display if this symbol is active
            const chartData = state.charts.get(symbol);
            if (chartData) {
                addTradeToDisplay(symbol, tradeData);
            }
        }

        // Add a single trade to the display
        function addTradeToDisplay(symbol, tradeData) {
            const container = document.getElementById(`trades-${symbol}`);
            if (!container) {
                return;
            }

            const chartData = state.charts.get(symbol);
            if (!chartData) {
                return;
            }

            // Determine price direction
            const priceClass = chartData.lastPrice && tradeData.price > chartData.lastPrice ? 'up' :
                              chartData.lastPrice && tradeData.price < chartData.lastPrice ? 'down' : '';

            // Format time in ET timezone
            const tradeTime = new Date(tradeData.timestamp).toLocaleTimeString('en-US', {
                timeZone: 'America/New_York',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });

            // Create trade item element
            const tradeItem = document.createElement('div');
            tradeItem.className = 'trade-item';
            tradeItem.innerHTML = `
                <div>
                    <div class="trade-time">${tradeTime} ET</div>
                    <div class="trade-price ${priceClass}">$${tradeData.price.toFixed(2)}</div>
                </div>
                <div class="trade-size">${tradeData.size.toLocaleString()}</div>
            `;

            // Add flash animation
            tradeItem.style.backgroundColor = 'rgba(78, 204, 163, 0.3)';
            setTimeout(() => {
                tradeItem.style.backgroundColor = '';
            }, 1000);

            // Insert at top
            container.insertBefore(tradeItem, container.firstChild);

            // Remove excess items (keep only 100)
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }

            // Update last price
            chartData.lastPrice = tradeData.price;
        }

        // Search functionality
        function handleSearchKeypress(event) {
            if (event.key === 'Enter') {
                handleSearch();
            }
        }

        function handleSearch() {
            const input = document.getElementById('symbolSearch');
            const symbol = input.value.trim().toUpperCase();

            if (!symbol) {
                alert('Please enter a stock symbol');
                return;
            }

            // Check if chart already exists
            if (state.charts.has(symbol)) {
                activateChart(symbol);
                input.value = '';
                return;
            }

            // Create new chart panel
            createChartPanel(symbol);
            input.value = '';
        }

        // Create a new chart panel
        function createChartPanel(symbol) {
            // Hide welcome message
            document.getElementById('welcomeMessage').style.display = 'none';

            // Create tab
            const tabBar = document.getElementById('tabBar');
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.id = `tab-${symbol}`;
            tab.onclick = () => activateChart(symbol);
            tab.innerHTML = `
                <span>${symbol}</span>
                <span class="tab-close" onclick="closeChart('${symbol}', event)">√ó</span>
            `;
            tabBar.appendChild(tab);

            // Create chart panel
            const chartContainer = document.getElementById('chartContainer');
            const panel = document.createElement('div');
            panel.className = 'chart-panel';
            panel.id = `panel-${symbol}`;
            panel.innerHTML = `
                <!-- Chart Controls -->
                <div class="chart-controls">
                    <div class="control-group">
                        <label>Interval:</label>
                        <button class="control-btn active" onclick="setChartInterval('${symbol}', '1m')">1m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '5m')">5m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '30m')">30m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '1h')">1h</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '1d')">1d</button>
                    </div>
                    <div class="control-group">
                        <label>Range:</label>
                        <button class="control-btn active" onclick="setRange('${symbol}', '1d')">1D</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '5d')">5D</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '1mo')">1M</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '1y')">1Y</button>
                    </div>
                    <div class="control-group">
                        <label style="color: var(--accent-green); font-weight: 600;">üïê Eastern Time (ET)</label>
                    </div>
                    <div class="control-group">
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'ema9', this.checked)">
                            EMA(9)
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'ema21', this.checked)">
                            EMA(21)
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'ema50', this.checked)">
                            EMA(50)
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'vwap', this.checked)">
                            VWAP
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'macd', this.checked)">
                            MACD
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" checked onchange="toggleIndicator('${symbol}', 'volume', this.checked)">
                            Volume
                        </label>
                    </div>
                </div>

                <!-- Chart Display -->
                <div class="chart-display">
                    <div class="chart-main">
                        <div class="loading active">
                            <div class="spinner"></div>
                            <div>Loading chart data for ${symbol}...</div>
                        </div>
                        <div class="canvas-container" id="canvas-${symbol}" style="display: none;">
                            <div class="main-chart" id="chart-${symbol}"></div>
                            <div class="volume-chart" id="volume-${symbol}"></div>
                        </div>
                    </div>

                    <div class="resize-handle"></div>

                    <!-- Time and Sales Panel -->
                    <div class="time-sales-panel">
                        <div class="time-sales-header">
                            Time & Sales - ${symbol}
                        </div>
                        <div class="time-sales-list" id="trades-${symbol}">
                            <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                                Loading trades...
                            </div>
                        </div>
                    </div>
                </div>
            `;
            chartContainer.appendChild(panel);

            // Initialize chart data
            state.charts.set(symbol, {
                interval: '1m',
                range: '1d',
                indicators: {
                    ema9: false,
                    ema21: false,
                    ema50: false,
                    vwap: false,
                    macd: false,
                    volume: true
                },
                chart: null,
                lastPrice: null,
                savedZoomState: null  // Track zoom/pan state
            });

            // Activate the new chart
            activateChart(symbol);

            // Load chart data
            loadChartData(symbol);

            // Start auto-update (every 30 seconds)
            const updateInterval = setInterval(() => loadChartData(symbol), 30000);
            state.updateIntervals.set(symbol, updateInterval);

            // Load initial historical trades (one-time)
            loadTimeSales(symbol);

            // Subscribe to real-time trades via WebSocket
            subscribeToSymbol(symbol);
        }

        // Activate a chart panel
        function activateChart(symbol) {
            // Deactivate all tabs and panels
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.chart-panel').forEach(panel => panel.classList.remove('active'));

            // Activate selected tab and panel
            document.getElementById(`tab-${symbol}`).classList.add('active');
            document.getElementById(`panel-${symbol}`).classList.add('active');

            state.activeChart = symbol;
        }

        // Close a chart panel
        function closeChart(symbol, event) {
            event.stopPropagation();

            // Unsubscribe from real-time trades
            unsubscribeFromSymbol(symbol);

            // Clear intervals
            if (state.updateIntervals.has(symbol)) {
                clearInterval(state.updateIntervals.get(symbol));
                state.updateIntervals.delete(symbol);
            }
            if (state.timeSalesIntervals.has(symbol)) {
                clearInterval(state.timeSalesIntervals.get(symbol));
                state.timeSalesIntervals.delete(symbol);
            }

            // Clean up chart and resize observer
            const chartData = state.charts.get(symbol);
            if (chartData) {
                if (chartData.resizeObserver) {
                    chartData.resizeObserver.disconnect();
                }
                if (chartData.volumeResizeObserver) {
                    chartData.volumeResizeObserver.disconnect();
                }
                if (chartData.chart) {
                    chartData.chart.remove();
                }
                if (chartData.volumeChart) {
                    chartData.volumeChart.remove();
                }
            }

            // Remove tab and panel
            document.getElementById(`tab-${symbol}`).remove();
            document.getElementById(`panel-${symbol}`).remove();

            // Remove from state
            state.charts.delete(symbol);

            // Activate another chart if available
            if (state.charts.size > 0) {
                const firstSymbol = state.charts.keys().next().value;
                activateChart(firstSymbol);
            } else {
                // Show welcome message if no charts
                document.getElementById('welcomeMessage').style.display = 'block';
                state.activeChart = null;
            }
        }

        // Control functions
        function setChartInterval(symbol, interval) {
            const panel = document.getElementById(`panel-${symbol}`);
            if (!panel) return;

            panel.querySelectorAll('.control-group:nth-child(1) .control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            const chartData = state.charts.get(symbol);
            chartData.interval = interval;
            loadChartData(symbol);
        }

        function setRange(symbol, range) {
            const panel = document.getElementById(`panel-${symbol}`);
            if (!panel) return;

            panel.querySelectorAll('.control-group:nth-child(2) .control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            const chartData = state.charts.get(symbol);
            chartData.range = range;
            loadChartData(symbol);
        }

        function toggleIndicator(symbol, indicator, enabled) {
            const chartData = state.charts.get(symbol);
            chartData.indicators[indicator] = enabled;
            loadChartData(symbol);
        }

        // Load chart data from backend
        async function loadChartData(symbol) {
            const chartData = state.charts.get(symbol);
            if (!chartData) {
                console.error('Chart data not found for symbol:', symbol);
                return;
            }

            try {
                updateStatus('Loading', `Fetching data for ${symbol}...`);

                // Build API URL
                const indicators = Object.keys(chartData.indicators)
                    .filter(key => chartData.indicators[key])
                    .join(',');

                const apiUrl = `./cgi-bin/api/market_data_api.py?action=chart&symbol=${symbol}&interval=${chartData.interval}&range=${chartData.range}&indicators=${indicators}`;
                console.log('Loading chart from:', apiUrl);

                // Fetch data from backend API
                const response = await fetch(apiUrl);
                const result = await response.json();

                console.log('Chart response:', result);

                if (!result.success) {
                    throw new Error(result.error || 'Failed to fetch chart data');
                }

                const data = result.data;

                if (!data.bars || data.bars.length === 0) {
                    throw new Error('No chart data available');
                }

                console.log(`Processing ${data.bars.length} bars for chart`);
                console.log('Sample raw bar data:', data.bars[0]);

                // Convert bar data to candlestick format for TradingView Lightweight Charts
                // Note: Timestamps from API are already in Eastern Time (ET) with timezone info
                // Example: "2025-10-27T04:00:00-04:00" (4:00 AM EDT)
                //
                // IMPORTANT: TradingView charts display timestamps in UTC, so we need to convert
                // ET time components to a "fake" UTC timestamp that displays the correct ET time
                const candlesticks = data.bars.map(bar => {
                    const timestamp = bar.timestamp;
                    const date = new Date(timestamp);

                    // Extract date/time components in ET timezone
                    const etDateString = date.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });

                    // Parse the ET string (format: "MM/DD/YYYY, HH:mm:ss")
                    const [datePart, timePart] = etDateString.split(', ');
                    const [month, day, year] = datePart.split('/');
                    const [hour, minute, second] = timePart.split(':');

                    // Create Unix timestamp treating ET components as UTC
                    // This makes the chart display ET times correctly
                    const unixTime = Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);

                    // Debug first bar conversion
                    if (bar === data.bars[0]) {
                        console.log('First bar conversion:', {
                            raw_timestamp: timestamp,
                            et_string: etDateString,
                            unix_seconds: unixTime,
                            display_time: new Date(unixTime * 1000).toISOString()
                        });
                    }

                    return {
                        time: unixTime,
                        open: bar.open,
                        high: bar.high,
                        low: bar.low,
                        close: bar.close
                    };
                });

                console.log('Candlesticks prepared:', candlesticks.length);
                console.log('First candlestick:', candlesticks[0]);
                console.log('Last candlestick:', candlesticks[candlesticks.length - 1]);

                // Convert volume timestamps using the same ET timezone conversion
                const volume = data.bars.map(bar => {
                    const date = new Date(bar.timestamp);
                    const etDateString = date.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    const [datePart, timePart] = etDateString.split(', ');
                    const [month, day, year] = datePart.split('/');
                    const [hour, minute, second] = timePart.split(':');
                    const unixTime = Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);

                    return {
                        time: unixTime,
                        value: bar.volume
                    };
                });

                renderChart(symbol, {
                    candlesticks,
                    indicators: data.indicators || {},
                    volume: volume
                });

                updateStatus('Connected', `${symbol} updated`);
                document.getElementById('updateTime').textContent =
                    `Last updated: ${new Date().toLocaleTimeString()}`;

            } catch (error) {
                console.error('Error loading chart data:', error);
                updateStatus('Error', `Failed to load data for ${symbol}: ${error.message}`);
            }
        }

        // Render chart
        function renderChart(symbol, data) {
            console.log('renderChart called for', symbol, 'with', data.candlesticks.length, 'candlesticks');

            const canvasContainer = document.getElementById(`canvas-${symbol}`);
            if (!canvasContainer) {
                console.error('Canvas container not found for', symbol);
                return;
            }

            const loading = canvasContainer.previousElementSibling;
            if (loading) {
                loading.classList.remove('active');
            }
            canvasContainer.style.display = 'block';

            const chartElement = document.getElementById(`chart-${symbol}`);
            if (!chartElement) {
                console.error('Chart element not found for', symbol);
                return;
            }

            const chartData = state.charts.get(symbol);
            if (!chartData) {
                console.error('Chart data state not found for', symbol);
                return;
            }

            // Destroy existing chart and disconnect ResizeObserver
            if (chartData.chart) {
                console.log('Removing existing chart');

                // Save current zoom/pan state before destroying chart
                try {
                    const currentRange = chartData.chart.timeScale().getVisibleLogicalRange();
                    if (currentRange) {
                        chartData.savedZoomState = currentRange;
                        console.log('Saved zoom state:', currentRange);
                    }
                } catch (error) {
                    console.warn('Could not save zoom state:', error);
                }

                if (chartData.resizeObserver) {
                    chartData.resizeObserver.disconnect();
                    chartData.resizeObserver = null;
                }
                if (chartData.volumeResizeObserver) {
                    chartData.volumeResizeObserver.disconnect();
                    chartData.volumeResizeObserver = null;
                }
                chartData.chart.remove();
                chartData.chart = null;
                if (chartData.volumeChart) {
                    chartData.volumeChart.remove();
                    chartData.volumeChart = null;
                }
            }

            // Wait for layout to complete before creating chart
            // This fixes the "chart appears then disappears" bug caused by 0x0 dimensions
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    createChart(chartElement, chartData, symbol, data);
                });
            });
        }

        // Create the actual chart (separated to handle async layout)
        function createChart(chartElement, chartData, symbol, data) {
            console.log('=== CREATE CHART CALLED ===');
            console.log('Chart element dimensions:', chartElement.clientWidth, 'x', chartElement.clientHeight);
            console.log('Candlesticks to render:', data.candlesticks.length);
            console.log('First 3 candlesticks:', data.candlesticks.slice(0, 3));

            // Check if element has dimensions
            if (chartElement.clientWidth === 0 || chartElement.clientHeight === 0) {
                console.error('Chart element has zero dimensions! Cannot create chart.');
                // Try again after a short delay
                setTimeout(() => {
                    console.log('Retrying chart creation after delay...');
                    createChart(chartElement, chartData, symbol, data);
                }, 100);
                return;
            }

            // Create new Lightweight Charts instance
            console.log('=== CREATING MAIN CHART ===');
            console.log('Main chart element ID:', chartElement.id);
            console.log('Main chart dimensions:', chartElement.clientWidth, 'x', chartElement.clientHeight);
            const chart = LightweightCharts.createChart(chartElement, {
                width: chartElement.clientWidth,
                height: chartElement.clientHeight,
                layout: {
                    background: { color: '#1a1a2e' },
                    textColor: '#d1d4dc',  // Brighter text for better visibility
                },
                grid: {
                    vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                    horzLines: { color: 'rgba(255, 255, 255, 0.1)' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 255, 255, 0.2)',
                },
                timeScale: {
                    borderColor: 'rgba(255, 255, 255, 0.8)',  // Much brighter border
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            // Force timeScale to be visible with bright colors
            console.log('Forcing timeScale visibility...');
            chart.applyOptions({
                layout: {
                    textColor: '#ffffff',  // Pure white for maximum visibility
                },
                timeScale: {
                    visible: true,
                    timeVisible: true,
                    secondsVisible: false,
                    borderColor: '#ffffff',  // Pure white border
                }
            });
            const timeScale = chart.timeScale();
            console.log('TimeScale object:', timeScale);
            console.log('Full TimeScale options:', timeScale.options());

            // Add candlestick series
            console.log('Adding candlestick series...');
            const candlestickSeries = chart.addCandlestickSeries({
                upColor: '#4ecca3',
                downColor: '#ff6b6b',
                borderVisible: false,
                wickUpColor: '#4ecca3',
                wickDownColor: '#ff6b6b',
            });

            // Set the candlestick data
            console.log('Setting candlestick data:', data.candlesticks.length, 'bars');
            if (data.candlesticks.length > 0) {
                console.log('First bar:', data.candlesticks[0]);
                console.log('Last bar:', data.candlesticks[data.candlesticks.length - 1]);
            }
            candlestickSeries.setData(data.candlesticks);
            console.log('Candlestick data set successfully');

            // Store chart reference
            chartData.chart = chart;
            chartData.candlestickSeries = candlestickSeries;
            chartData.indicatorSeries = {};

            // Helper function to convert timestamps from ET to display correctly in UTC charts
            function convertTimestampToET(timestamp) {
                const date = new Date(timestamp);
                const etDateString = date.toLocaleString('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                const [datePart, timePart] = etDateString.split(', ');
                const [month, day, year] = datePart.split('/');
                const [hour, minute, second] = timePart.split(':');
                return Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);
            }

            // Add indicator series if available
            const indicators = data.indicators || {};

            // EMA indicators
            if (indicators.ema9 && indicators.ema9.length > 0) {
                const ema9Series = chart.addLineSeries({
                    color: '#2962FF',
                    lineWidth: 2,
                    title: 'EMA(9)'
                });
                const ema9Data = indicators.ema9.map(item => ({
                    time: convertTimestampToET(item.time),
                    value: item.value
                }));
                ema9Series.setData(ema9Data);
                chartData.indicatorSeries.ema9 = ema9Series;
            }

            if (indicators.ema21 && indicators.ema21.length > 0) {
                const ema21Series = chart.addLineSeries({
                    color: '#FF6D00',
                    lineWidth: 2,
                    title: 'EMA(21)'
                });
                const ema21Data = indicators.ema21.map(item => ({
                    time: convertTimestampToET(item.time),
                    value: item.value
                }));
                ema21Series.setData(ema21Data);
                chartData.indicatorSeries.ema21 = ema21Series;
            }

            if (indicators.ema50 && indicators.ema50.length > 0) {
                const ema50Series = chart.addLineSeries({
                    color: '#00E676',
                    lineWidth: 2,
                    title: 'EMA(50)'
                });
                const ema50Data = indicators.ema50.map(item => ({
                    time: convertTimestampToET(item.time),
                    value: item.value
                }));
                ema50Series.setData(ema50Data);
                chartData.indicatorSeries.ema50 = ema50Series;
            }

            if (indicators.ema200 && indicators.ema200.length > 0) {
                const ema200Series = chart.addLineSeries({
                    color: '#D500F9',
                    lineWidth: 2,
                    title: 'EMA(200)'
                });
                const ema200Data = indicators.ema200.map(item => ({
                    time: convertTimestampToET(item.time),
                    value: item.value
                }));
                ema200Series.setData(ema200Data);
                chartData.indicatorSeries.ema200 = ema200Series;
            }

            // VWAP indicator
            if (indicators.vwap && indicators.vwap.length > 0) {
                const vwapSeries = chart.addLineSeries({
                    color: '#FFD600',
                    lineWidth: 2,
                    lineStyle: 2, // Dashed line
                    title: 'VWAP'
                });
                const vwapData = indicators.vwap.map(item => ({
                    time: convertTimestampToET(item.time),
                    value: item.value
                }));
                vwapSeries.setData(vwapData);
                chartData.indicatorSeries.vwap = vwapSeries;
            }

            // Create separate volume chart
            if (chartData.indicators.volume && data.volume && data.volume.length > 0) {
                const volumeElement = document.getElementById(`volume-${symbol}`);
                if (volumeElement) {
                    console.log('=== CREATING VOLUME CHART ===');
                    console.log('Volume chart element ID:', volumeElement.id);
                    console.log('Volume chart dimensions:', volumeElement.clientWidth, 'x', volumeElement.clientHeight);
                    console.log('Volume element parent:', volumeElement.parentElement.id);

                    // Check if volume element has dimensions
                    if (volumeElement.clientWidth === 0 || volumeElement.clientHeight === 0) {
                        console.warn('Volume chart element has zero dimensions! Width:', volumeElement.clientWidth, 'Height:', volumeElement.clientHeight);
                        // Continue anyway - ResizeObserver will fix it when it gets dimensions
                    }

                    const volumeChart = LightweightCharts.createChart(volumeElement, {
                        width: volumeElement.clientWidth,
                        height: volumeElement.clientHeight,
                        layout: {
                            background: { color: '#1a1a2e' },
                            textColor: '#d1d4dc',
                        },
                        grid: {
                            vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                            horzLines: { color: 'rgba(255, 255, 255, 0.1)' },
                        },
                        rightPriceScale: {
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                        },
                        timeScale: {
                            borderColor: 'rgba(255, 255, 255, 0.8)',
                            timeVisible: true,
                            secondsVisible: false,
                        },
                    });

                    const volumeSeries = volumeChart.addHistogramSeries({
                        color: '#26a69a',
                        priceFormat: {
                            type: 'volume',
                        },
                    });
                    volumeSeries.setData(data.volume);

                    // Store volume chart reference
                    chartData.volumeChart = volumeChart;
                    chartData.indicatorSeries.volume = volumeSeries;

                    // Sync time scales between main chart and volume chart
                    // Use flags to prevent infinite loop
                    let syncingToVolume = false;
                    let syncingToMain = false;

                    chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                        if (syncingToMain) return;
                        const range = chart.timeScale().getVisibleLogicalRange();
                        if (range) {
                            syncingToVolume = true;
                            volumeChart.timeScale().setVisibleLogicalRange(range);
                            syncingToVolume = false;
                            // Save zoom state whenever user changes it
                            chartData.savedZoomState = range;
                        }
                    });

                    volumeChart.timeScale().subscribeVisibleTimeRangeChange(() => {
                        if (syncingToVolume) return;
                        const range = volumeChart.timeScale().getVisibleLogicalRange();
                        if (range) {
                            syncingToMain = true;
                            chart.timeScale().setVisibleLogicalRange(range);
                            syncingToMain = false;
                            // Save zoom state whenever user changes it
                            chartData.savedZoomState = range;
                        }
                    });

                    // Handle volume chart resize
                    const volumeResizeObserver = new ResizeObserver(entries => {
                        if (entries.length === 0) return;
                        const { width, height } = entries[0].contentRect;
                        volumeChart.applyOptions({ width, height });
                    });
                    volumeResizeObserver.observe(volumeElement);

                    // Store for cleanup
                    chartData.volumeResizeObserver = volumeResizeObserver;
                }
            } else {
                // If no volume chart, still track zoom state changes on main chart
                chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                    const range = chart.timeScale().getVisibleLogicalRange();
                    if (range) {
                        chartData.savedZoomState = range;
                    }
                });
            }

            // Handle window resize
            const resizeObserver = new ResizeObserver(entries => {
                if (entries.length === 0) return;
                const { width, height } = entries[0].contentRect;
                chart.applyOptions({ width, height });
            });
            resizeObserver.observe(chartElement);

            // Store resize observer for cleanup
            chartData.resizeObserver = resizeObserver;

            // Restore saved zoom state or set default view
            const barsCount = data.candlesticks.length;
            if (barsCount > 0) {
                if (chartData.savedZoomState) {
                    // Restore previous zoom/pan state
                    console.log('Restoring saved zoom state:', chartData.savedZoomState);
                    try {
                        chart.timeScale().setVisibleLogicalRange(chartData.savedZoomState);
                        console.log('Zoom state restored successfully');
                    } catch (error) {
                        console.warn('Could not restore zoom state, using default:', error);
                        // Fall back to default view
                        const visibleBars = Math.min(100, barsCount);
                        chart.timeScale().setVisibleLogicalRange({
                            from: barsCount - visibleBars,
                            to: barsCount - 1
                        });
                    }
                } else {
                    // Show last 100 bars (or all bars if less than 100) for new charts
                    const visibleBars = Math.min(100, barsCount);
                    chart.timeScale().setVisibleLogicalRange({
                        from: barsCount - visibleBars,
                        to: barsCount - 1
                    });
                    console.log('TimeScale set to show bars', barsCount - visibleBars, 'to', barsCount - 1);
                }
                console.log('TimeScale options:', chart.timeScale().options());
            }

            // Debug: Check if chart is actually visible in DOM
            console.log('Chart element parent dimensions:', chartElement.parentElement.clientWidth, 'x', chartElement.parentElement.clientHeight);
            console.log('Chart element computed style:', window.getComputedStyle(chartElement).display);

            // Check if timeScale element exists in DOM
            setTimeout(() => {
                const allTables = chartElement.querySelectorAll('table');
                console.log('Found', allTables.length, 'table elements in chart');

                if (allTables.length > 0) {
                    const table = allTables[0];
                    const rows = table.querySelectorAll('tr');
                    console.log('Found', rows.length, 'table rows');

                    if (rows.length > 1) {
                        console.log('Row 0 (main chart) height:', rows[0].querySelector('td')?.style.height);
                        console.log('Row 1 (timeScale) height:', rows[1].querySelector('td')?.style.height);

                        // Check the canvas in the timeScale row
                        const timeScaleCanvas = rows[1].querySelector('canvas');
                        if (timeScaleCanvas) {
                            console.log('TimeScale canvas found! Dimensions:', timeScaleCanvas.width, 'x', timeScaleCanvas.height);
                            console.log('TimeScale canvas style:', timeScaleCanvas.style.cssText);
                        } else {
                            console.log('No canvas found in timeScale row!');
                        }
                    }
                }
            }, 500);
        }

        // Load time and sales data
        async function loadTimeSales(symbol) {
            const container = document.getElementById(`trades-${symbol}`);
            if (!container) {
                console.error(`Time & sales container not found for ${symbol}`);
                return;
            }

            try {
                const apiUrl = `./cgi-bin/api/market_data_api.py?action=trades&symbol=${symbol}&limit=100`;
                console.log('Loading trades from:', apiUrl);

                const response = await fetch(apiUrl);
                const result = await response.json();

                console.log('Trades response:', result);

                if (!result.success) {
                    console.error('Error loading trades:', result.error);
                    container.innerHTML = `<div style="text-align: center; color: var(--accent-red); padding: 20px;">
                        Error loading trades: ${result.error}
                    </div>`;
                    return;
                }

                if (!result.data || !result.data.trades || result.data.trades.length === 0) {
                    container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                        No recent trades available
                    </div>`;
                    return;
                }

                renderTimeSales(symbol, result.data.trades);
            } catch (error) {
                console.error('Error loading time & sales:', error);
                container.innerHTML = `<div style="text-align: center; color: var(--accent-red); padding: 20px;">
                    Failed to load trades
                </div>`;
            }
        }

        // Render time and sales
        function renderTimeSales(symbol, trades) {
            const container = document.getElementById(`trades-${symbol}`);
            const chartData = state.charts.get(symbol);

            if (!container || !chartData) {
                console.error('Cannot render trades - container or chartData missing');
                return;
            }

            console.log(`Rendering ${trades.length} trades for ${symbol}`);

            // Reverse trades so newest are at the top
            const reversedTrades = [...trades].reverse();

            container.innerHTML = reversedTrades.map(trade => {
                const priceClass = chartData.lastPrice && trade.price > chartData.lastPrice ? 'up' :
                                  chartData.lastPrice && trade.price < chartData.lastPrice ? 'down' : '';

                // Format time in ET timezone
                const tradeTime = new Date(trade.timestamp).toLocaleTimeString('en-US', {
                    timeZone: 'America/New_York',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });

                return `
                    <div class="trade-item">
                        <div>
                            <div class="trade-time">${tradeTime} ET</div>
                            <div class="trade-price ${priceClass}">$${trade.price.toFixed(2)}</div>
                        </div>
                        <div class="trade-size">${trade.size.toLocaleString()}</div>
                    </div>
                `;
            }).join('');

            if (trades.length > 0) {
                // Use the most recent trade (last in original array, first in reversed)
                chartData.lastPrice = trades[trades.length - 1].price;
            }

            // Auto-scroll to top to show newest trades
            container.scrollTop = 0;
        }

        // Update status bar
        function updateStatus(status, message) {
            document.getElementById('statusText').textContent = `${status}: ${message}`;
        }

        // Mock data generators (to be replaced with backend calls)
        function generateMockData(symbol, interval, range) {
            const candlesticks = [];
            const numBars = range === '1d' ? 390 : range === '5d' ? 1950 : 100;
            let basePrice = 150 + Math.random() * 50;

            for (let i = 0; i < numBars; i++) {
                // Lightweight Charts requires Unix timestamp in SECONDS (not milliseconds)
                const timeMs = Date.now() - (numBars - i) * 60000;
                const time = Math.floor(timeMs / 1000);

                const open = basePrice;
                const close = basePrice + (Math.random() - 0.5) * 5;
                const high = Math.max(open, close) + Math.random() * 2;
                const low = Math.min(open, close) - Math.random() * 2;

                candlesticks.push({
                    time: time,
                    open: Number(open.toFixed(2)),
                    high: Number(high.toFixed(2)),
                    low: Number(low.toFixed(2)),
                    close: Number(close.toFixed(2))
                });

                basePrice = close;
            }

            return { candlesticks };
        }

        function generateMockTrades(symbol) {
            const trades = [];
            let basePrice = 150 + Math.random() * 50;

            for (let i = 0; i < 20; i++) {
                const price = basePrice + (Math.random() - 0.5) * 2;
                trades.push({
                    timestamp: new Date(Date.now() - (20 - i) * 5000),
                    price: price,
                    size: Math.floor(Math.random() * 1000) + 100
                });
                basePrice = price;
            }

            return trades.reverse();
        }

        // ========================================
        // WATCH LIST FUNCTIONALITY
        // ========================================

        // Watch list state
        const watchListState = {
            symbols: [],
            manualSymbols: new Set(),  // Track manually added symbols
            deletedSymbols: new Set(), // Track deleted symbols (to hide on auto-refresh)
            refreshInterval: null
        };

        // Initialize watch list on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadWatchList();
            // Refresh watch list every 60 seconds
            watchListState.refreshInterval = setInterval(loadWatchList, 60000);
        });

        // Load watch list from API
        async function loadWatchList() {
            try {
                console.log('Loading watch list from API...');
                const response = await fetch('cgi-bin/api/watch_list_api.py');
                console.log('Watch list API response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Watch list data received:', data);

                if (data.success) {
                    // Filter out deleted symbols (unless they were manually re-added)
                    watchListState.symbols = data.data.filter(symbol => {
                        // Keep if NOT deleted, OR if deleted but manually re-added
                        return !watchListState.deletedSymbols.has(symbol.symbol) ||
                               watchListState.manualSymbols.has(symbol.symbol);
                    });

                    // Also add back any manual symbols that aren't in the API response
                    const apiSymbols = new Set(data.data.map(s => s.symbol));
                    watchListState.manualSymbols.forEach(manualSymbol => {
                        if (!apiSymbols.has(manualSymbol) && !watchListState.symbols.find(s => s.symbol === manualSymbol)) {
                            // Add manual symbol if it's not already in the list
                            watchListState.symbols.push({
                                symbol: manualSymbol,
                                oracle: false,
                                manual: true,
                                top_gainers: false,
                                surge: false
                            });
                        }
                    });

                    // Sort alphabetically
                    watchListState.symbols.sort((a, b) => a.symbol.localeCompare(b.symbol));

                    console.log(`Loaded ${watchListState.symbols.length} symbols from watch list (${data.count} from API, ${watchListState.deletedSymbols.size} deleted, ${watchListState.manualSymbols.size} manual)`);
                    renderWatchList();
                } else {
                    console.error('Failed to load watch list:', data.error);
                    showWatchListError(`Failed to load watch list: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error loading watch list:', error);
                showWatchListError(`Error loading watch list: ${error.message}`);
            }
        }

        // Render watch list table
        function renderWatchList() {
            const tbody = document.getElementById('watchListBody');

            if (!watchListState.symbols || watchListState.symbols.length === 0) {
                tbody.innerHTML = `
                    <tr class="watch-list-empty">
                        <td colspan="6">No symbols in watch list</td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = watchListState.symbols.map(symbol => `
                <tr ondblclick="openChartFromWatchList('${symbol.symbol}')">
                    <td class="symbol-cell">${symbol.symbol}</td>
                    <td class="source-cell">
                        <span class="source-indicator ${symbol.oracle ? 'on' : 'off'}"
                              title="${symbol.oracle ? 'Oracle: Yes' : 'Oracle: No'}"></span>
                    </td>
                    <td class="source-cell">
                        <span class="source-indicator ${symbol.manual ? 'on' : 'off'}"
                              title="${symbol.manual ? 'Manual: Yes' : 'Manual: No'}"></span>
                    </td>
                    <td class="source-cell">
                        <span class="source-indicator ${symbol.top_gainers ? 'on' : 'off'}"
                              title="${symbol.top_gainers ? 'Top Gainers: Yes' : 'Top Gainers: No'}"></span>
                    </td>
                    <td class="source-cell">
                        <span class="source-indicator ${symbol.surge ? 'on' : 'off'}"
                              title="${symbol.surge ? 'Volume Surge: Yes' : 'Volume Surge: No'}"></span>
                    </td>
                    <td class="del-cell">
                        <button class="delete-btn"
                                onclick="event.stopPropagation(); deleteSymbolFromWatchList('${symbol.symbol}')"
                                title="Delete ${symbol.symbol}">
                            üóëÔ∏è
                        </button>
                    </td>
                </tr>
            `).join('');
        }

        // Show watch list error
        function showWatchListError(message) {
            const tbody = document.getElementById('watchListBody');
            tbody.innerHTML = `
                <tr class="watch-list-empty">
                    <td colspan="6" style="color: var(--accent-red);">${message}</td>
                </tr>
            `;
        }

        // Open chart from watch list (double-click)
        function openChartFromWatchList(symbol) {
            if (!symbol) return;

            console.log(`Opening chart for ${symbol} from watch list`);

            // Set search input value
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.value = symbol.toUpperCase();
            }

            // Open chart
            handleSearch();
        }

        // Handle keypress in watch list add input
        function handleWatchListKeypress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                addSymbolToWatchList();
            }
        }

        // Add symbol to watch list
        function addSymbolToWatchList() {
            const input = document.getElementById('watchListAddInput');
            if (!input) return;

            const symbol = input.value.trim().toUpperCase();

            if (!symbol) {
                return;
            }

            // Check if symbol already exists
            const exists = watchListState.symbols.some(s => s.symbol === symbol);
            if (exists) {
                console.log(`Symbol ${symbol} already in watch list`);
                input.value = '';
                return;
            }

            // If this symbol was previously deleted, remove it from deleted set
            // This allows it to show up again even after auto-refresh
            if (watchListState.deletedSymbols.has(symbol)) {
                watchListState.deletedSymbols.delete(symbol);
                console.log(`Symbol ${symbol} was previously deleted, now re-adding as manual`);
            }

            // Add symbol to list
            const newSymbol = {
                symbol: symbol,
                oracle: false,
                manual: true,
                top_gainers: false,
                surge: false
            };

            watchListState.symbols.push(newSymbol);
            watchListState.manualSymbols.add(symbol);

            // Re-sort symbols
            watchListState.symbols.sort((a, b) => a.symbol.localeCompare(b.symbol));

            // Render and clear input
            renderWatchList();
            input.value = '';

            console.log(`Added ${symbol} to watch list (manual symbols: ${watchListState.manualSymbols.size})`);
        }

        // Delete symbol from watch list
        function deleteSymbolFromWatchList(symbol) {
            if (!symbol) return;

            console.log(`Deleting ${symbol} from watch list`);

            // Check if this is a manually added symbol
            const isManual = watchListState.manualSymbols.has(symbol);

            // Remove from symbols array
            watchListState.symbols = watchListState.symbols.filter(s => s.symbol !== symbol);

            if (isManual) {
                // If it was manually added, remove from manual set
                watchListState.manualSymbols.delete(symbol);
                console.log(`Removed ${symbol} from manual symbols`);
            } else {
                // If it came from API, add to deleted set to prevent it from showing up on auto-refresh
                watchListState.deletedSymbols.add(symbol);
                console.log(`Added ${symbol} to deleted symbols (will hide on auto-refresh)`);
            }

            // Re-render
            renderWatchList();

            console.log(`Deleted ${symbol} from watch list (manual: ${watchListState.manualSymbols.size}, deleted: ${watchListState.deletedSymbols.size})`);
        }
    </script>
</body>
</html>
