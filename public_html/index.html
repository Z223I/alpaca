<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Sentinel - Real-time Stock Monitor</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">

    <!-- TradingView Lightweight Charts for professional candlestick charts -->
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --text-primary: #e4e4e4;
            --text-secondary: #a0a0a0;
            --accent-green: #4ecca3;
            --accent-red: #ff6b6b;
            --accent-blue: #4dabf7;
            --border-color: #2a2a3e;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Header */
        .header {
            background-color: var(--bg-secondary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--accent-green);
        }

        /* Search Bar */
        .search-container {
            display: flex;
            align-items: center;
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            padding: 8px 15px;
            flex: 0 0 400px;
        }

        .search-container input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 16px;
            outline: none;
            flex: 1;
            padding: 5px;
            text-transform: uppercase;
        }

        .search-container input::placeholder {
            color: var(--text-secondary);
        }

        .search-icon {
            cursor: pointer;
            color: var(--accent-blue);
            font-size: 20px;
            margin-left: 10px;
        }

        .search-icon:hover {
            color: var(--accent-green);
        }

        .premarket-icon-external {
            cursor: pointer;
            color: var(--accent-blue);
            font-size: 24px;
            margin-left: 20px;
            transition: color 0.2s ease;
        }

        .premarket-icon-external:hover {
            color: var(--accent-green);
            transform: scale(1.1);
        }

        /* Fundamentals Icon in Header */
        .fundamentals-icon-header {
            cursor: pointer;
            color: var(--accent-blue);
            font-size: 24px;
            margin-left: 20px;
            transition: all 0.2s ease;
        }

        .fundamentals-icon-header:hover {
            color: var(--accent-green);
            transform: scale(1.1);
        }

        /* Fundamentals Popup */
        .fundamentals-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fundamentals-popup-content {
            background-color: var(--bg-secondary);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .fundamentals-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }

        .fundamentals-popup-header h2 {
            font-size: 22px;
            color: var(--accent-green);
            margin: 0;
        }

        .fundamentals-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }

        .fundamentals-close-btn:hover {
            color: var(--accent-red);
        }

        .fundamentals-input-container {
            margin-bottom: 20px;
        }

        .fundamentals-input-container label {
            display: block;
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 8px;
        }

        .fundamentals-input-container input {
            width: 100%;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-primary);
            font-size: 16px;
            padding: 12px;
            text-transform: uppercase;
        }

        .fundamentals-input-container input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .fundamentals-fetch-btn {
            width: 100%;
            background-color: var(--accent-blue);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            padding: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .fundamentals-fetch-btn:hover {
            background-color: var(--accent-green);
        }

        .fundamentals-fetch-btn:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }

        .fundamentals-popup-data {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .fundamentals-popup-data h3 {
            font-size: 18px;
            color: var(--accent-blue);
            margin-bottom: 15px;
        }

        .fundamentals-popup-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 14px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .fundamentals-popup-label {
            color: var(--text-secondary);
        }

        .fundamentals-popup-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Main Container */
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
        }

        /* Tab Bar */
        .tab-bar {
            background-color: var(--bg-secondary);
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 5px;
            overflow-x: auto;
            min-height: 50px;
        }

        .tab {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 5px 5px 0 0;
            padding: 10px 20px;
            cursor: move;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background-color 0.2s;
        }

        .tab.dragging {
            opacity: 0.5;
        }

        .tab.drag-over {
            border-left: 3px solid var(--accent-green);
        }

        .tab:hover {
            background-color: var(--bg-primary);
        }

        .tab.active {
            background-color: var(--bg-primary);
            border-bottom: 2px solid var(--accent-green);
        }

        .tab-close {
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
        }

        .tab-close:hover {
            color: var(--accent-red);
        }

        /* Chart Container */
        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
            overflow: hidden;
        }

        .chart-panel {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
        }

        .chart-panel.active {
            display: flex;
        }

        /* Chart Controls */
        .chart-controls {
            background-color: var(--bg-secondary);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            color: var(--text-secondary);
            font-size: 14px;
            margin-right: 5px;
        }

        .control-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background-color: var(--accent-blue);
            color: white;
        }

        .control-btn.active {
            background-color: var(--accent-green);
            color: white;
            border-color: var(--accent-green);
        }

        .control-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        .control-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .indicator-note {
            font-size: 0.75em;
            color: var(--text-secondary);
            opacity: 0.7;
            font-style: italic;
        }

        .save-settings-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            margin-left: 10px;
        }

        .save-settings-btn:hover {
            background-color: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }

        .save-settings-btn.saved {
            background-color: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }

        /* Chart Display Area */
        .chart-display {
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
            display: flex;
            overflow: auto;  /* Enable scrolling to debug */
        }

        .chart-main {
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
            padding: 20px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .canvas-container {
            flex: 1;
            min-height: 0;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
        }

        .main-chart {
            flex: 3;
            width: 100%;
            min-height: 500px;
            background-color: #16213e;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
        }

        /* Chart Legend */
        .chart-legend {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(26, 26, 46, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 10px 15px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.6;
            pointer-events: auto;
        }

        .legend-symbol {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent-blue);
            margin-bottom: 5px;
        }

        .legend-price {
            font-size: 16px;
            font-weight: 600;
        }

        .legend-price.up {
            color: var(--accent-green);
        }

        .legend-price.down {
            color: var(--accent-red);
        }

        .legend-change {
            font-size: 13px;
            margin-left: 8px;
        }

        .legend-details {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 3px;
        }

        .legend-indicators {
            font-size: 11px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-indicator-item {
            margin: 2px 0;
            display: flex;
            align-items: center;
        }

        .legend-indicator-color {
            width: 12px;
            height: 2px;
            margin-right: 6px;
            display: inline-block;
        }

        .legend-indicator-label {
            color: var(--text-secondary);
            margin-right: 4px;
        }

        .legend-indicator-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .legend-volume {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 3px;
        }

        .legend-volume-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .legend-fundamentals {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-fundamentals-item {
            margin: 2px 0;
        }

        .legend-fundamentals-item span {
            color: var(--text-primary);
            font-weight: 500;
        }

        .volume-chart {
            flex: 1;
            width: 100%;
            min-height: 120px;
            background-color: #0f3460;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
        }

        /* Chart Resize Handle (between main chart and volume chart) */
        .chart-resize-handle {
            width: 100%;
            height: 8px;
            cursor: row-resize;
            background-color: transparent;
            position: relative;
            z-index: 100;
            transition: background-color 0.2s;
            margin: 5px 0;
        }

        .chart-resize-handle:hover {
            background-color: var(--accent-blue);
        }

        .chart-resize-handle.resizing {
            background-color: var(--accent-green);
        }

        /* Time and Sales Panel */
        .time-sales-panel {
            width: 300px;
            min-width: 200px;
            max-width: 600px;
            background-color: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Time & Sales Resize Handle */
        .time-sales-resize {
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            background-color: transparent;
            z-index: 10;
            transition: background-color 0.2s;
            pointer-events: auto;
        }

        .time-sales-resize:hover {
            background-color: var(--accent-blue);
        }

        .time-sales-panel.resizing {
            user-select: none;
        }

        .time-sales-panel.resizing .time-sales-resize {
            background-color: var(--accent-green);
        }

        .time-sales-header {
            background-color: var(--bg-tertiary);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .time-sales-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .trade-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .trade-item:hover {
            background-color: var(--bg-tertiary);
        }

        .trade-item.up {
            background-color: rgba(78, 204, 163, 0.15);
        }

        .trade-item.down {
            background-color: rgba(255, 107, 107, 0.15);
        }

        .trade-time {
            color: var(--text-secondary);
            font-size: 11px;
        }

        .trade-price {
            font-weight: 600;
        }

        .trade-price.up {
            color: var(--accent-green);
        }

        .trade-price.down {
            color: var(--accent-red);
        }

        .trade-size {
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Resize Handle */
        .resize-handle {
            width: 5px;
            background-color: var(--border-color);
            cursor: col-resize;
            position: relative;
        }

        .resize-handle:hover {
            background-color: var(--accent-blue);
        }

        /* Status Bar */
        .status-bar {
            background-color: var(--bg-secondary);
            padding: 8px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--accent-green);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }

        /* Loading Spinner */
        .loading {
            display: none;
            text-align: center;
            padding: 50px;
            color: var(--text-secondary);
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Left Sidebar Container */
        .left-sidebar {
            width: 595px;
            min-width: 500px;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            border-right: 2px solid var(--border-color);
            overflow: hidden;
            padding-bottom: 30px; /* Add space at bottom */
            position: relative; /* For resize handle positioning */
        }

        /* Left Sidebar Resize Handle */
        .left-sidebar-resize {
            position: absolute;
            top: 0;
            right: 12px;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            background-color: transparent;
            z-index: 10;
            transition: background-color 0.2s;
        }

        .left-sidebar-resize:hover {
            background-color: var(--accent-blue);
        }

        .left-sidebar.resizing {
            user-select: none;
        }

        .left-sidebar.resizing .left-sidebar-resize {
            background-color: var(--accent-green);
        }

        /* Premarket Popup */
        .premarket-popup {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .premarket-popup-content {
            background-color: var(--bg-secondary);
            margin: 5% auto;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 90%;
            max-width: 1200px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .premarket-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .premarket-popup-header h2 {
            margin: 0;
            color: var(--text-primary);
        }

        .premarket-close-btn {
            background: none;
            border: none;
            font-size: 28px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .premarket-close-btn:hover {
            color: var(--accent-red);
        }

        .premarket-popup-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .premarket-loading,
        .premarket-error {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            font-size: 16px;
        }

        .premarket-error {
            color: var(--accent-red);
        }

        .premarket-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        .premarket-table th {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid var(--border-color);
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .premarket-table th:hover {
            background-color: var(--bg-primary);
        }

        .premarket-table th .sort-indicator {
            margin-left: 5px;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .premarket-table th.sorted-asc .sort-indicator,
        .premarket-table th.sorted-desc .sort-indicator {
            color: var(--accent-blue);
        }

        .premarket-table td {
            padding: 10px 8px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .premarket-table tr:hover {
            background-color: var(--bg-tertiary);
        }

        .premarket-table .gain-positive {
            color: var(--accent-green);
            font-weight: 600;
        }

        .premarket-table .gain-negative {
            color: var(--accent-red);
            font-weight: 600;
        }

        .premarket-table .symbol-cell {
            cursor: pointer;
            color: var(--accent-blue);
            font-weight: 600;
        }

        .premarket-table .symbol-cell:hover {
            text-decoration: underline;
        }

        /* Watch List Panel */
        .watch-list-panel {
            flex: 1;
            background-color: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .watch-list-header {
            background-color: var(--bg-tertiary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .watch-list-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-green);
            margin: 0;
        }

        .watch-list-add-container {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
        }

        .watch-list-add-input {
            flex: 1;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            text-transform: uppercase;
        }

        .watch-list-add-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .watch-list-add-btn {
            background-color: var(--accent-green);
            border: none;
            color: var(--bg-primary);
            padding: 8px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .watch-list-add-btn:hover {
            background-color: #3dba8a;
        }

        .watch-list-table-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
        }

        .watch-list-table {
            width: 100%;
            border-collapse: collapse;
        }

        .watch-list-table thead {
            position: sticky;
            top: 0;
            background-color: var(--bg-tertiary);
            z-index: 10;
        }

        .watch-list-table th {
            padding: 12px 10px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-color);
            white-space: nowrap;
            cursor: default;
        }

        .watch-list-table th[onclick] {
            cursor: pointer;
        }

        .watch-list-table th[onclick]:hover {
            background-color: var(--bg-secondary);
        }

        .watch-list-table th.source-col {
            text-align: center;
            width: 60px;
        }

        .watch-list-table th.surge-col {
            text-align: right;
            width: 80px;
        }

        .watch-list-table th.gain-col {
            text-align: right;
            width: 80px;
        }

        .watch-list-table th.del-col {
            text-align: center;
            width: 50px;
        }

        .watch-list-table th .sort-indicator {
            margin-left: 5px;
            color: var(--text-secondary);
            font-size: 12px;
        }

        .watch-list-table th.sorted-asc .sort-indicator,
        .watch-list-table th.sorted-desc .sort-indicator {
            color: var(--accent-blue);
        }

        .watch-list-table tbody tr {
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .watch-list-table tbody tr:hover {
            background-color: var(--bg-tertiary);
        }

        .watch-list-table td {
            padding: 10px;
            font-size: 14px;
        }

        .watch-list-table td.symbol-cell {
            font-weight: 600;
            color: var(--accent-blue);
        }

        .watch-list-table td.source-cell {
            text-align: center;
            font-size: 16px;
        }

        .watch-list-table td.surge-cell {
            text-align: right;
            font-weight: 600;
            font-size: 13px;
        }

        .watch-list-table td.gain-cell {
            text-align: right;
            font-weight: 600;
            font-size: 13px;
        }

        .watch-list-table td.gain-cell.positive {
            color: var(--accent-green);
        }

        .watch-list-table td.gain-cell.negative {
            color: var(--accent-red);
        }

        .watch-list-table td.del-cell {
            text-align: center;
        }

        .source-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 0 2px;
        }

        .source-indicator.on {
            background-color: var(--accent-green);
        }

        .source-indicator.off {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
        }

        .delete-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s;
        }

        .delete-btn:hover {
            color: var(--accent-red);
        }

        .watch-list-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Scanner Panel */
        .scanner-panel {
            flex: 1;
            background-color: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* Scanner Subpanel */
        .scanner-subpanel {
            background-color: var(--bg-tertiary);
            border-top: 2px solid var(--border-color);
            height: 60px;
            flex-shrink: 0;
            margin-bottom: 20px; /* Add space at bottom so content doesn't go off screen */
        }

        .scanner-header {
            background-color: var(--bg-tertiary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .scanner-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-green);
            margin: 0;
        }

        .scanner-table-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            padding-bottom: 60px; /* Add space at bottom so last rows are visible */
        }

        .scanner-table {
            width: 100%;
            border-collapse: collapse;
        }

        .scanner-table thead {
            position: sticky;
            top: 0;
            background-color: var(--bg-tertiary);
            z-index: 10;
        }

        .scanner-table th {
            padding: 8px 6px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-color);
            white-space: nowrap;
            position: relative;
            user-select: none;
        }

        /* Column resize handle */
        .scanner-table th .resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            background-color: transparent;
            z-index: 1;
        }

        .scanner-table th .resize-handle:hover {
            background-color: var(--accent-blue);
        }

        .scanner-table th.resizing {
            border-right: 2px solid var(--accent-blue);
        }

        .scanner-table th.source-col {
            text-align: center;
            width: 80px;
        }

        .scanner-table th.time-col {
            width: 80px;
        }

        .scanner-table th.price-col {
            text-align: right;
            width: 70px;
        }

        .scanner-table th.gain-col {
            text-align: right;
            width: 70px;
        }

        .scanner-table tbody tr {
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .scanner-table tbody tr:hover {
            background-color: var(--bg-tertiary);
        }

        .scanner-table td {
            padding: 6px;
            font-size: 14px;
        }

        .scanner-table td.symbol-cell {
            font-weight: 600;
            color: var(--accent-blue);
        }

        .scanner-table td.source-cell {
            text-align: center;
            font-weight: 600;
            color: var(--accent-green);
        }

        .scanner-table td.source-cell.squeeze-source {
            color: var(--accent-orange);
        }

        .scanner-table td.time-cell {
            color: var(--text-secondary);
            font-size: 12px;
        }

        .scanner-table td.price-cell {
            text-align: right;
            color: var(--text-primary);
            font-size: 13px;
        }

        .scanner-table td.gain-cell {
            text-align: right;
            font-weight: 600;
        }

        .scanner-table td.gain-cell.positive {
            color: var(--accent-green);
        }

        .scanner-table td.gain-cell.negative {
            color: var(--accent-red);
        }

        .scanner-table td.text-cell {
            font-size: 11px;
            color: var(--text-secondary);
            max-width: 200px;
        }

        .scanner-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Welcome Message */
        .welcome-message {
            text-align: center;
            padding: 100px 50px;
            color: var(--text-secondary);
        }

        .welcome-message h2 {
            font-size: 36px;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .welcome-message p {
            font-size: 18px;
            line-height: 1.6;
        }

    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>üìä Market Sentinel</h1>
        <div class="search-container">
            <input
                type="text"
                id="symbolSearch"
                placeholder="Enter stock symbol (e.g., AAPL, GOOGL, TSLA)"
                onkeypress="handleSearchKeypress(event)"
            />
            <span class="search-icon" onclick="handleSearch()">üîç</span>
        </div>
        <span class="premarket-icon-external" onclick="openPremarketPopup()" title="View Premarket Top Gainers (Ctrl+G)">üåÖ</span>
        <span class="fundamentals-icon-header" onclick="openFundamentalsPopup()" title="View Stock Fundamentals">üìä</span>
    </div>

    <!-- Fundamentals Popup -->
    <div id="fundamentalsPopup" class="fundamentals-popup" style="display: none;">
        <div class="fundamentals-popup-content">
            <div class="fundamentals-popup-header">
                <h2>Company Fundamentals</h2>
                <button class="fundamentals-close-btn" onclick="closeFundamentalsPopup()">‚úï</button>
            </div>

            <div class="fundamentals-input-container">
                <label for="fundamentalsSymbolInput">Enter Stock Symbol</label>
                <input
                    type="text"
                    id="fundamentalsSymbolInput"
                    placeholder="e.g., AAPL, NVDA, TSLA"
                    onkeypress="handleFundamentalsKeypress(event)"
                />
            </div>

            <button class="fundamentals-fetch-btn" onclick="fetchFundamentalsForPopup()">Get Fundamentals</button>

            <div id="fundamentalsPopupData" style="display: none;" class="fundamentals-popup-data">
                <!-- Fundamentals data will be populated here -->
            </div>
        </div>
    </div>

    <!-- Premarket Top Gainers Popup -->
    <div id="premarketPopup" class="premarket-popup" style="display: none;">
        <div class="premarket-popup-content">
            <div class="premarket-popup-header">
                <h2>üåÖ Premarket Top Gainers</h2>
                <button class="premarket-close-btn" onclick="closePremarketPopup()">‚úï</button>
            </div>
            <div class="premarket-popup-body">
                <div id="premarketLoading" class="premarket-loading">Loading...</div>
                <div id="premarketError" class="premarket-error" style="display: none;"></div>
                <div id="premarketTableContainer" style="display: none;">
                    <table class="premarket-table" id="premarketTable">
                        <thead>
                            <tr>
                                <th onclick="sortPremarketTable('symbol')">Symbol <span class="sort-indicator"></span></th>
                                <th onclick="sortPremarketTable('prev_close')">Previous Close <span class="sort-indicator"></span></th>
                                <th onclick="sortPremarketTable('current_price')">Current Price <span class="sort-indicator"></span></th>
                                <th onclick="sortPremarketTable('gain_percent')" class="sorted-desc">Gain % <span class="sort-indicator">‚ñº</span></th>
                                <th onclick="sortPremarketTable('pm_volume')">PM Volume <span class="sort-indicator"></span></th>
                                <th onclick="sortPremarketTable('pm_range')">PM Range <span class="sort-indicator"></span></th>
                            </tr>
                        </thead>
                        <tbody id="premarketTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab Bar -->
    <div class="tab-bar" id="tabBar">
        <!-- Tabs will be added dynamically -->
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Sidebar: Watch List + Scanner -->
        <div class="left-sidebar">
            <!-- Watch List Panel -->
            <div class="watch-list-panel">
            <div class="watch-list-header">
                <h2>üìã Watch List</h2>
            </div>

            <!-- Add Symbol Section -->
            <div class="watch-list-add-container">
                <input
                    type="text"
                    id="watchListAddInput"
                    class="watch-list-add-input"
                    placeholder="Add symbol..."
                    onkeypress="handleWatchListKeypress(event)"
                />
                <button class="watch-list-add-btn" onclick="addSymbolToWatchList()">Add</button>
            </div>

            <!-- Symbol Table -->
            <div class="watch-list-table-container">
                <table class="watch-list-table">
                    <thead>
                        <tr>
                            <th onclick="sortWatchList('symbol')">Symbol <span class="sort-indicator"></span></th>
                            <th class="source-col" onclick="sortWatchList('manual')" title="Manual">‚úèÔ∏è <span class="sort-indicator"></span></th>
                            <th class="source-col" onclick="sortWatchList('news')" title="News">üì∞ <span class="sort-indicator"></span></th>
                            <th class="source-col" onclick="sortWatchList('top_gainers')" title="Premarket Top Gainers">üåÖ <span class="sort-indicator"></span></th>
                            <th class="source-col" onclick="sortWatchList('alpaca_top_gainers')" title="Alpaca Top Gainers">üìà <span class="sort-indicator"></span></th>
                            <th class="surge-col" onclick="sortWatchList('surge_amount')" title="Volume Surge Ratio">Surge <span class="sort-indicator"></span></th>
                            <th class="gain-col" onclick="sortWatchList('gain_percent')" title="Percent Gain">Gain <span class="sort-indicator"></span></th>
                            <th class="del-col">Del</th>
                        </tr>
                    </thead>
                    <tbody id="watchListBody">
                        <!-- Symbols will be populated here -->
                        <tr class="watch-list-empty">
                            <td colspan="9">Loading watch list...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Scanner Panel -->
        <div class="scanner-panel">
            <div class="scanner-header">
                <h2>üîç Scanner</h2>
            </div>

            <!-- Scanner Table -->
            <div class="scanner-table-container">
                <table class="scanner-table">
                    <thead>
                        <tr>
                            <th>Symbol<div class="resize-handle"></div></th>
                            <th class="source-col">Source<div class="resize-handle"></div></th>
                            <th class="time-col">Time<div class="resize-handle"></div></th>
                            <th class="price-col">Price<div class="resize-handle"></div></th>
                            <th class="gain-col">Gain<div class="resize-handle"></div></th>
                            <th>Text<div class="resize-handle"></div></th>
                        </tr>
                    </thead>
                    <tbody id="scannerBody">
                        <!-- Alerts will be populated here -->
                        <tr class="scanner-empty">
                            <td colspan="6">Loading scanner...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Scanner Subpanel -->
        <div class="scanner-subpanel">
        </div>

        <!-- Left Sidebar Resize Handle -->
        <div class="left-sidebar-resize" id="leftSidebarResize"></div>
        </div><!-- End of left-sidebar -->

        <div class="chart-container" id="chartContainer">
            <!-- Welcome Message (shown when no charts open) -->
            <div class="welcome-message" id="welcomeMessage">
                <h2>Welcome to Market Sentinel</h2>
                <p>Enter a stock symbol in the search bar above to begin monitoring real-time market data.</p>
                <p>Features include candlestick charts, EMAs, VWAP, MACD, volume analysis, and time & sales data.</p>
            </div>

            <!-- Chart panels will be added dynamically -->
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-indicator">
            <span class="status-dot"></span>
            <span id="statusText">Ready</span>
        </div>
        <div>
            <span id="updateTime">Last updated: Never</span>
        </div>
    </div>

    <script>
        console.log('‚úÖ SCRIPT START - Beginning of main script block');

        // Global state
        const state = {
            charts: new Map(),
            activeChart: null,
            updateIntervals: new Map(),
            tradeWebSocket: null,
            tradeBuffer: new Map(),  // Buffer for real-time trades
            wsReconnectAttempts: 0,
            wsMaxReconnectAttempts: 5,
            leftSidebarResize: {
                isResizing: false,
                startX: 0,
                startWidth: 0
            },
            timeSalesResize: {
                isResizing: false,
                currentPanel: null,
                chartMain: null,
                startX: 0,
                startWidth: 0,
                startChartWidth: 0
            },
            chartResize: {
                isResizing: false,
                currentMainChart: null,
                currentVolumeChart: null,
                startY: 0,
                startMainHeight: 0,
                startVolumeHeight: 0
            }
        };

        // Exchange code to name mapping (Source: Alpaca API Documentation)
        const EXCHANGE_NAMES = {
            'A': 'NYSE American (AMEX)',
            'B': 'NASDAQ OMX BX',
            'C': 'National Stock Exchange',
            'D': 'FINRA ADF',
            'E': 'Market Independent',
            'H': 'MIAX',
            'I': 'International Securities Exchange',
            'J': 'Cboe EDGA',
            'K': 'Cboe EDGX',
            'L': 'Long Term Stock Exchange',
            'M': 'Chicago Stock Exchange',
            'N': 'NYSE',
            'P': 'NYSE Arca',
            'Q': 'NASDAQ OMX',
            'S': 'NASDAQ Small Cap',
            'T': 'NASDAQ Int',
            'U': 'Members Exchange',
            'V': 'IEX',
            'W': 'CBOE',
            'X': 'NASDAQ OMX PSX',
            'Y': 'Cboe BYX',
            'Z': 'Cboe BZX'
        };

        // Convert exchange code to full name
        function getExchangeName(code) {
            if (!code) return 'N/A';
            return EXCHANGE_NAMES[code] || code;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Market Sentinel initialized');
            updateStatus('Ready', 'System initialized');
            initializeTradeWebSocket();
            initLeftSidebarResize();

            // Auto-focus search bar on page load
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.focus();
            }
        });

        // Global keyboard handler - any keystroke focuses search bar
        document.addEventListener('keydown', (event) => {
            const searchInput = document.getElementById('symbolSearch');
            const activeElement = document.activeElement;

            // Check for Ctrl+G to open premarket popup
            if (event.ctrlKey && event.key.toLowerCase() === 'g') {
                event.preventDefault();
                openPremarketPopup();
                return;
            }

            // Don't interfere if user is already typing in any input field or textarea
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                return;
            }

            // Don't interfere with special keys (Ctrl, Alt, etc.) or function keys
            if (event.ctrlKey || event.altKey || event.metaKey || event.key.startsWith('F')) {
                return;
            }

            // Don't interfere with navigation keys when not in search
            const navigationKeys = ['Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
            if (navigationKeys.includes(event.key)) {
                return;
            }

            // For any other printable character, focus the search bar
            if (event.key.length === 1 || event.key === 'Backspace') {
                searchInput.focus();
                // If it's a backspace, let it work on the search field
                // If it's a character, it will be automatically added to the focused input
            }
        });

        // Initialize WebSocket connection for real-time trades
        function initializeTradeWebSocket() {
            const wsUrl = 'ws://' + (window.location.hostname || 'localhost') + ':8766';
            console.log('Connecting to trade stream:', wsUrl);
            updateStatus('Connecting', 'Connecting to real-time trade stream...');

            try {
                state.tradeWebSocket = new WebSocket(wsUrl);

                state.tradeWebSocket.onopen = () => {
                    console.log('‚úÖ WebSocket connected to trade stream');
                    updateStatus('Connected', 'Real-time trade stream active');
                    state.wsReconnectAttempts = 0;

                    // Resubscribe to all active symbols
                    state.charts.forEach((chartData, symbol) => {
                        subscribeToSymbol(symbol);
                    });
                };

                state.tradeWebSocket.onmessage = (event) => {
                    handleTradeMessage(event.data);
                };

                state.tradeWebSocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Error', 'Trade stream connection error');
                };

                state.tradeWebSocket.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateStatus('Disconnected', 'Trade stream disconnected');
                    state.tradeWebSocket = null;

                    // Attempt reconnection
                    if (state.wsReconnectAttempts < state.wsMaxReconnectAttempts) {
                        state.wsReconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, state.wsReconnectAttempts), 30000);
                        console.log(`Reconnecting in ${delay/1000}s (attempt ${state.wsReconnectAttempts}/${state.wsMaxReconnectAttempts})...`);
                        setTimeout(initializeTradeWebSocket, delay);
                    } else {
                        console.error('Max reconnection attempts reached. Please refresh the page.');
                        updateStatus('Error', 'Trade stream unavailable. Please refresh page.');
                    }
                };

                // Keep-alive ping every 30 seconds
                setInterval(() => {
                    if (state.tradeWebSocket && state.tradeWebSocket.readyState === WebSocket.OPEN) {
                        state.tradeWebSocket.send(JSON.stringify({ action: 'ping' }));
                    }
                }, 30000);

            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                updateStatus('Error', 'Failed to connect to trade stream');
            }
        }

        // Subscribe to real-time trades for a symbol
        function subscribeToSymbol(symbol) {
            if (!state.tradeWebSocket || state.tradeWebSocket.readyState !== WebSocket.OPEN) {
                console.warn('WebSocket not ready, cannot subscribe to', symbol);
                return;
            }

            console.log('Subscribing to real-time trades for', symbol);
            state.tradeWebSocket.send(JSON.stringify({
                action: 'subscribe',
                symbol: symbol
            }));

            // Initialize trade buffer for this symbol
            if (!state.tradeBuffer.has(symbol)) {
                state.tradeBuffer.set(symbol, []);
            }
        }

        // Unsubscribe from real-time trades for a symbol
        function unsubscribeFromSymbol(symbol) {
            if (!state.tradeWebSocket || state.tradeWebSocket.readyState !== WebSocket.OPEN) {
                return;
            }

            console.log('Unsubscribing from real-time trades for', symbol);
            state.tradeWebSocket.send(JSON.stringify({
                action: 'unsubscribe',
                symbol: symbol
            }));

            // Clear trade buffer
            state.tradeBuffer.delete(symbol);
        }

        // Handle incoming WebSocket trade messages
        function handleTradeMessage(message) {
            try {
                const data = JSON.parse(message);

                if (data.type === 'trade') {
                    handleRealTimeTrade(data.symbol, data.data);
                } else if (data.type === 'subscribed') {
                    console.log('‚úÖ Subscribed to', data.symbol);
                } else if (data.type === 'unsubscribed') {
                    console.log('Unsubscribed from', data.symbol);
                } else if (data.type === 'pong') {
                    // Keep-alive response
                }
            } catch (error) {
                console.error('Error handling trade message:', error);
            }
        }

        // Handle a real-time trade update
        function handleRealTimeTrade(symbol, tradeData) {
            console.log(`Real-time trade for ${symbol}:`, tradeData);

            // Add symbol to tradeData if not present
            if (!tradeData.symbol) {
                tradeData.symbol = symbol;
            }

            // Add to buffer
            const buffer = state.tradeBuffer.get(symbol) || [];
            buffer.unshift(tradeData);  // Add to front (newest first)

            // Keep only last 100 trades in buffer
            if (buffer.length > 100) {
                buffer.pop();
            }
            state.tradeBuffer.set(symbol, buffer);

            // Update display if this symbol is active
            const chartData = state.charts.get(symbol);
            if (chartData) {
                addTradeToDisplay(symbol, tradeData);
            }
        }

        // Add a single trade to the display
        function addTradeToDisplay(symbol, tradeData) {
            const container = document.getElementById(`trades-${symbol}`);
            if (!container) {
                return;
            }

            const chartData = state.charts.get(symbol);
            if (!chartData) {
                return;
            }

            // Determine price direction
            const priceClass = chartData.lastPrice && tradeData.price > chartData.lastPrice ? 'up' :
                              chartData.lastPrice && tradeData.price < chartData.lastPrice ? 'down' : '';

            // Format time in ET timezone
            const tradeTime = new Date(tradeData.timestamp).toLocaleTimeString('en-US', {
                timeZone: 'America/New_York',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });

            // Get exchange name
            const exchangeName = getExchangeName(tradeData.exchange);
            const symbolDisplay = tradeData.symbol || 'UNK';

            // Create trade item element
            const tradeItem = document.createElement('div');
            tradeItem.className = `trade-item ${priceClass}`;
            tradeItem.innerHTML = `
                <div>
                    <div class="trade-time">${tradeTime} ET</div>
                    <div class="trade-price ${priceClass}">$${tradeData.price.toFixed(2)}</div>
                    <div class="trade-time" style="margin-top: 2px;">${symbolDisplay} - ${exchangeName}</div>
                </div>
                <div class="trade-size">${tradeData.size.toLocaleString()}</div>
            `;

            // Check if user is scrolled to top (within 50px threshold)
            const isScrolledToTop = container.scrollTop < 50;

            // Insert at top
            container.insertBefore(tradeItem, container.firstChild);

            // Remove excess items (keep only 100)
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }

            // Auto-scroll to top to show newest trades (only if already near top)
            if (isScrolledToTop) {
                container.scrollTop = 0;
            }

            // Update last price
            chartData.lastPrice = tradeData.price;
        }

        // ========================================
        // LEFT SIDEBAR RESIZE FUNCTIONALITY
        // ========================================

        function initLeftSidebarResize() {
            const leftSidebar = document.querySelector('.left-sidebar');
            const resizeHandle = document.getElementById('leftSidebarResize');

            if (!leftSidebar || !resizeHandle) {
                console.warn('Left sidebar or resize handle not found');
                return;
            }

            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                state.leftSidebarResize.isResizing = true;
                state.leftSidebarResize.startX = e.pageX;
                state.leftSidebarResize.startWidth = leftSidebar.offsetWidth;

                leftSidebar.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', (e) => {
                if (!state.leftSidebarResize.isResizing) return;

                const diff = e.pageX - state.leftSidebarResize.startX;
                const newWidth = state.leftSidebarResize.startWidth + diff;

                // Enforce min and max width constraints
                const minWidth = 500;
                const maxWidth = 900;

                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    leftSidebar.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (state.leftSidebarResize.isResizing) {
                    state.leftSidebarResize.isResizing = false;
                    leftSidebar.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

        // ========================================
        // TIME & SALES RESIZE FUNCTIONALITY
        // ========================================

        function initTimeSalesResize(symbol) {
            const timeSalesPanel = document.getElementById(`time-sales-${symbol}`);
            const resizeHandle = timeSalesPanel?.querySelector('.time-sales-resize');

            if (!timeSalesPanel || !resizeHandle) {
                console.warn(`Time & Sales panel or resize handle not found for ${symbol}`);
                return;
            }

            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Find the chart-main element (sibling in the chart-display div)
                const chartDisplay = timeSalesPanel.parentElement;
                const chartMain = chartDisplay?.querySelector('.chart-main');

                state.timeSalesResize.isResizing = true;
                state.timeSalesResize.currentPanel = timeSalesPanel;
                state.timeSalesResize.chartMain = chartMain;
                state.timeSalesResize.startX = e.pageX;
                state.timeSalesResize.startWidth = timeSalesPanel.offsetWidth;
                state.timeSalesResize.startChartWidth = chartMain?.offsetWidth || 0;

                timeSalesPanel.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            // Use existing global mousemove handler
            if (!state.timeSalesResize.mouseMoveAttached) {
                document.addEventListener('mousemove', (e) => {
                    if (!state.timeSalesResize.isResizing) return;

                    // Calculate new width (subtract because we're dragging from left edge)
                    // Dragging left (decreasing pageX) should increase width
                    // Dragging right (increasing pageX) should decrease width
                    const diff = state.timeSalesResize.startX - e.pageX;
                    let newWidth = state.timeSalesResize.startWidth + diff;

                    // Enforce min and max width constraints
                    const minWidth = 200;
                    const maxWidth = 600;

                    // Clamp the width
                    newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

                    // Update Time & Sales panel width
                    state.timeSalesResize.currentPanel.style.width = newWidth + 'px';
                    state.timeSalesResize.currentPanel.style.flexShrink = '0';

                    // Update chart-main width (inverse relationship)
                    if (state.timeSalesResize.chartMain) {
                        const newChartWidth = state.timeSalesResize.startChartWidth - diff;
                        state.timeSalesResize.chartMain.style.width = newChartWidth + 'px';
                        state.timeSalesResize.chartMain.style.flex = 'none';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (state.timeSalesResize.isResizing) {
                        state.timeSalesResize.isResizing = false;
                        if (state.timeSalesResize.currentPanel) {
                            state.timeSalesResize.currentPanel.classList.remove('resizing');
                        }
                        state.timeSalesResize.currentPanel = null;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                });

                state.timeSalesResize.mouseMoveAttached = true;
            }
        }

        // ========================================
        // CHART RESIZE FUNCTIONALITY
        // ========================================

        function initChartResize(symbol) {
            const mainChart = document.getElementById(`chart-${symbol}`);
            const volumeChart = document.getElementById(`volume-${symbol}`);
            const resizeHandle = document.querySelector(`.chart-resize-handle[data-symbol="${symbol}"]`);

            if (!mainChart || !volumeChart || !resizeHandle) {
                console.warn(`Chart elements or resize handle not found for ${symbol}`);
                return;
            }

            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();

                state.chartResize.isResizing = true;
                state.chartResize.currentMainChart = mainChart;
                state.chartResize.currentVolumeChart = volumeChart;
                state.chartResize.startY = e.pageY;
                state.chartResize.startMainHeight = mainChart.offsetHeight;
                state.chartResize.startVolumeHeight = volumeChart.offsetHeight;

                resizeHandle.classList.add('resizing');
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
            });

            // Use existing global mousemove handler
            if (!state.chartResize.mouseMoveAttached) {
                document.addEventListener('mousemove', (e) => {
                    if (!state.chartResize.isResizing) return;

                    const diff = e.pageY - state.chartResize.startY;
                    const newMainHeight = state.chartResize.startMainHeight + diff;
                    const newVolumeHeight = state.chartResize.startVolumeHeight - diff;

                    // Enforce minimum heights
                    const minMainHeight = 300;
                    const minVolumeHeight = 100;

                    if (newMainHeight >= minMainHeight && newVolumeHeight >= minVolumeHeight) {
                        state.chartResize.currentMainChart.style.height = newMainHeight + 'px';
                        state.chartResize.currentMainChart.style.flex = 'none';
                        state.chartResize.currentVolumeChart.style.height = newVolumeHeight + 'px';
                        state.chartResize.currentVolumeChart.style.flex = 'none';

                        // Resize the TradingView charts
                        const chartData = state.charts.get(symbol);
                        if (chartData && chartData.chart) {
                            chartData.chart.applyOptions({
                                width: state.chartResize.currentMainChart.offsetWidth,
                                height: newMainHeight
                            });
                        }
                        if (chartData && chartData.volumeChart) {
                            chartData.volumeChart.applyOptions({
                                width: state.chartResize.currentVolumeChart.offsetWidth,
                                height: newVolumeHeight
                            });
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (state.chartResize.isResizing) {
                        state.chartResize.isResizing = false;
                        const resizeHandles = document.querySelectorAll('.chart-resize-handle');
                        resizeHandles.forEach(h => h.classList.remove('resizing'));
                        state.chartResize.currentMainChart = null;
                        state.chartResize.currentVolumeChart = null;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                });

                state.chartResize.mouseMoveAttached = true;
            }
        }

        // ========================================
        // SEARCH FUNCTIONALITY
        // ========================================

        function handleSearchKeypress(event) {
            if (event.key === 'Enter') {
                handleSearch();
            }
        }

        function handleSearch() {
            const input = document.getElementById('symbolSearch');
            const symbol = input.value.trim().toUpperCase();

            if (!symbol) {
                alert('Please enter a stock symbol');
                return;
            }

            // Check if chart already exists
            if (state.charts.has(symbol)) {
                activateChart(symbol);
                input.value = '';
                return;
            }

            // Create new chart panel
            createChartPanel(symbol);
            input.value = '';
        }

        // Create a new chart panel
        async function createChartPanel(symbol) {
            // Hide welcome message
            document.getElementById('welcomeMessage').style.display = 'none';

            // Fetch company name from backend
            let companyName = '';
            try {
                const response = await fetch(`cgi-bin/api/momentum_alerts_api.py?action=company_name&symbol=${symbol}`);
                const result = await response.json();
                if (result.success && result.company_name) {
                    companyName = result.company_name;
                }
            } catch (error) {
                console.error(`Failed to fetch company name for ${symbol}:`, error);
            }

            // Create display text for symbol (with company name if available)
            const symbolDisplay = companyName ? `${symbol} - ${companyName}` : symbol;

            // Create tab
            const tabBar = document.getElementById('tabBar');
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.id = `tab-${symbol}`;
            tab.draggable = true;
            tab.onclick = () => activateChart(symbol);
            // Use symbolDisplay (with company name) in tab if available, otherwise just symbol
            const tabText = symbolDisplay || symbol;
            tab.innerHTML = `
                <span title="${tabText}">${symbol}</span>
                <span class="tab-close" onclick="closeChart('${symbol}', event)">√ó</span>
            `;

            // Add drag event listeners
            tab.addEventListener('dragstart', handleTabDragStart);
            tab.addEventListener('dragend', handleTabDragEnd);
            tab.addEventListener('dragover', handleTabDragOver);
            tab.addEventListener('drop', handleTabDrop);
            tab.addEventListener('dragleave', handleTabDragLeave);

            tabBar.appendChild(tab);

            // Create chart panel
            const chartContainer = document.getElementById('chartContainer');
            const panel = document.createElement('div');
            panel.className = 'chart-panel';
            panel.id = `panel-${symbol}`;
            panel.innerHTML = `
                <!-- Chart Controls -->
                <div class="chart-controls">
                    <div class="control-group">
                        <label>Interval:</label>
                        <button class="control-btn active" onclick="setChartInterval('${symbol}', '1m')">1m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '5m')">5m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '30m')">30m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '1h')">1h</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '1d')">1d</button>
                    </div>
                    <div class="control-group">
                        <label>Range:</label>
                        <button class="control-btn active" onclick="setRange('${symbol}', '1d')">1D</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '5d')">5D</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '1mo')">1M</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '1y')">1Y</button>
                    </div>
                    <div class="control-group">
                        <label class="control-checkbox">
                            <input type="checkbox" id="ema9-checkbox-${symbol}" onchange="toggleIndicator('${symbol}', 'ema9', this.checked)">
                            EMA(9)
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" id="ema21-checkbox-${symbol}" onchange="toggleIndicator('${symbol}', 'ema21', this.checked)">
                            EMA(21)
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" id="ema50-checkbox-${symbol}" onchange="toggleIndicator('${symbol}', 'ema50', this.checked)">
                            EMA(50)
                        </label>
                        <label class="control-checkbox" id="vwap-label-${symbol}">
                            <input type="checkbox" id="vwap-checkbox-${symbol}" onchange="toggleIndicator('${symbol}', 'vwap', this.checked)">
                            VWAP <span class="indicator-note">(1D only)</span>
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" id="macd-checkbox-${symbol}" onchange="toggleIndicator('${symbol}', 'macd', this.checked)">
                            MACD
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" id="volume-checkbox-${symbol}" checked onchange="toggleIndicator('${symbol}', 'volume', this.checked)">
                            Volume
                        </label>
                        <button class="save-settings-btn" id="save-btn-${symbol}" onclick="saveChartSettings('${symbol}')" title="Save chart settings">üíæ</button>
                    </div>
                </div>

                <!-- Chart Display -->
                <div class="chart-display">
                    <div class="chart-main">
                        <div class="loading active">
                            <div class="spinner"></div>
                            <div>Loading chart data for ${symbol}...</div>
                        </div>
                        <div class="canvas-container" id="canvas-${symbol}" style="display: none;">
                            <div class="main-chart" id="chart-${symbol}">
                                <div class="chart-legend" id="legend-${symbol}">
                                    <div class="legend-symbol">${symbolDisplay}</div>
                                    <div class="legend-price" id="legend-price-${symbol}">--</div>
                                    <div class="legend-details" id="legend-details-${symbol}">
                                        O: -- H: -- L: -- C: --
                                    </div>
                                    <div class="legend-fundamentals" id="legend-fundamentals-${symbol}">
                                        <div class="legend-fundamentals-item">Float: <span id="legend-float-${symbol}">--</span></div>
                                        <div class="legend-fundamentals-item">Float Rotation: <span id="legend-float-rotation-${symbol}">--</span></div>
                                        <div class="legend-fundamentals-item">Sector: <span id="legend-sector-${symbol}">--</span></div>
                                        <div class="legend-fundamentals-item">Industry: <span id="legend-industry-${symbol}">--</span></div>
                                    </div>
                                    <div class="legend-volume" id="legend-volume-${symbol}"></div>
                                    <div class="legend-indicators" id="legend-indicators-${symbol}"></div>
                                </div>
                            </div>

                            <!-- Chart Resize Handle -->
                            <div class="chart-resize-handle" data-symbol="${symbol}"></div>

                            <div class="volume-chart" id="volume-${symbol}"></div>
                        </div>
                    </div>

                    <div class="resize-handle"></div>

                    <!-- Time and Sales Panel -->
                    <div class="time-sales-panel" id="time-sales-${symbol}">
                        <!-- Resize Handle -->
                        <div class="time-sales-resize" data-symbol="${symbol}"></div>

                        <div class="time-sales-header">
                            <span>Time & Sales - ${symbol}</span>
                        </div>
                        <div class="time-sales-list" id="trades-${symbol}">
                            <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                                Waiting for real-time trades...
                            </div>
                        </div>
                    </div>
                </div>
            `;
            chartContainer.appendChild(panel);

            // Initialize Time & Sales resize for this panel
            initTimeSalesResize(symbol);

            // Initialize chart resize for this panel
            initChartResize(symbol);

            // Initialize chart data
            state.charts.set(symbol, {
                interval: '1m',
                range: '1d',
                companyName: companyName,  // Store company name for legend updates
                indicators: {
                    ema9: false,
                    ema21: false,
                    ema50: false,
                    vwap: false,
                    macd: false,
                    volume: true
                },
                chart: null,
                lastPrice: null
            });

            // Update legend with company name (if available)
            const legendSymbolElement = document.querySelector(`#legend-${symbol} .legend-symbol`);
            if (legendSymbolElement && companyName) {
                legendSymbolElement.textContent = `${symbol} - ${companyName}`;
            }

            // Activate the new chart
            activateChart(symbol);

            // Try to load saved global settings
            const savedSettings = loadChartSettings();
            if (savedSettings) {
                applyChartSettings(symbol, savedSettings);
            }

            // Load chart data
            loadChartData(symbol);

            // Load fundamentals for legend
            loadLegendFundamentals(symbol);

            // Start auto-update with adaptive refresh rate based on chart interval
            const getRefreshInterval = (interval) => {
                switch(interval) {
                    case '1m': return 30000;  // 30 seconds for 1-minute charts
                    case '5m': return 30000;  // 30 seconds for 5-minute charts
                    case '30m': return 30000; // 30 seconds for 30-minute charts
                    case '1h': return 60000;  // 60 seconds for hourly charts
                    case '1d': return 60000;  // 60 seconds for daily charts
                    default: return 30000;    // Default 30 seconds
                }
            };

            // Get chart data to determine refresh interval
            const chartData = state.charts.get(symbol);
            const refreshInterval = getRefreshInterval(chartData.interval);
            console.log(`Chart refresh interval for ${symbol} (${chartData.interval}): ${refreshInterval}ms`);
            const updateInterval = setInterval(() => loadChartData(symbol), refreshInterval);
            state.updateIntervals.set(symbol, updateInterval);

            // Subscribe to real-time trades via WebSocket only (no historical load)
            subscribeToSymbol(symbol);
        }

        // Calculate float rotation based on current date's volume
        function calculateFloatRotation(symbol, floatShares) {
            const chartData = state.charts.get(symbol);
            if (!chartData || !chartData.volumeData) {
                console.log(`No volume data available for ${symbol} to calculate float rotation`);
                return null;
            }

            // Get today's date in ET timezone
            const today = new Date();
            const todayET = today.toLocaleDateString('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });

            // Sum volume for all bars from current date
            let totalVolume = 0;
            const volumeData = chartData.volumeData;
            if (volumeData && volumeData.length > 0) {
                volumeData.forEach(bar => {
                    // Convert bar timestamp to ET date
                    const barDate = new Date(bar.time * 1000);
                    const barDateET = barDate.toLocaleDateString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    });

                    // If bar is from today, add its volume
                    if (barDateET === todayET) {
                        totalVolume += bar.value;
                    }
                });
            }

            console.log(`Float rotation calculation for ${symbol}: totalVolume=${totalVolume}, floatShares=${floatShares}`);

            if (totalVolume === 0 || !floatShares || floatShares === 0) {
                return null;
            }

            const floatRotation = totalVolume / floatShares;
            return floatRotation;
        }

        // Load fundamentals for chart legend
        async function loadLegendFundamentals(symbol) {
            const floatElement = document.getElementById(`legend-float-${symbol}`);
            const floatRotationElement = document.getElementById(`legend-float-rotation-${symbol}`);
            const sectorElement = document.getElementById(`legend-sector-${symbol}`);
            const industryElement = document.getElementById(`legend-industry-${symbol}`);

            if (!floatElement || !floatRotationElement || !sectorElement || !industryElement) return;

            try {
                const response = await fetch(`cgi-bin/api/stock_fundamentals_api.py?symbol=${symbol}`);
                const data = await response.json();

                if (data.success) {
                    floatElement.textContent = data.float_shares_formatted || 'N/A';
                    sectorElement.textContent = data.sector || 'N/A';
                    industryElement.textContent = data.industry || 'N/A';

                    // Calculate float rotation from volume data
                    const floatShares = data.float_shares || 0;
                    const chartData = state.charts.get(symbol);

                    // Store float shares for later recalculation
                    if (chartData) {
                        chartData.floatShares = floatShares;
                    }

                    // Calculate and display float rotation
                    const floatRotation = calculateFloatRotation(symbol, floatShares);
                    if (floatRotation !== null) {
                        floatRotationElement.textContent = `${floatRotation.toFixed(2)}x`;
                    } else {
                        floatRotationElement.textContent = 'N/A';
                    }
                } else {
                    console.error(`Failed to load fundamentals for ${symbol}:`, data.error);
                    floatElement.textContent = 'N/A';
                    floatRotationElement.textContent = 'N/A';
                    sectorElement.textContent = 'N/A';
                    industryElement.textContent = 'N/A';
                }
            } catch (error) {
                console.error(`Error loading fundamentals for ${symbol}:`, error);
                floatElement.textContent = 'N/A';
                floatRotationElement.textContent = 'N/A';
                sectorElement.textContent = 'N/A';
                industryElement.textContent = 'N/A';
            }
        }

        // Update float rotation in legend (call after chart data updates)
        function updateLegendFloatRotation(symbol) {
            const chartData = state.charts.get(symbol);
            if (!chartData || !chartData.floatShares) {
                return;
            }

            const floatRotationElement = document.getElementById(`legend-float-rotation-${symbol}`);
            if (!floatRotationElement) return;

            const floatRotation = calculateFloatRotation(symbol, chartData.floatShares);
            if (floatRotation !== null) {
                floatRotationElement.textContent = `${floatRotation.toFixed(2)}x`;
            }
        }

        // Activate a chart panel
        function activateChart(symbol) {
            // Deactivate all tabs and panels
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.chart-panel').forEach(panel => panel.classList.remove('active'));

            // Activate selected tab and panel
            document.getElementById(`tab-${symbol}`).classList.add('active');
            document.getElementById(`panel-${symbol}`).classList.add('active');

            state.activeChart = symbol;
        }

        // Close a chart panel
        function closeChart(symbol, event) {
            event.stopPropagation();

            // Unsubscribe from real-time trades
            unsubscribeFromSymbol(symbol);

            // Clear chart update interval
            if (state.updateIntervals.has(symbol)) {
                clearInterval(state.updateIntervals.get(symbol));
                state.updateIntervals.delete(symbol);
            }

            // Clean up chart and resize observer
            const chartData = state.charts.get(symbol);
            if (chartData) {
                if (chartData.resizeObserver) {
                    chartData.resizeObserver.disconnect();
                }
                if (chartData.volumeResizeObserver) {
                    chartData.volumeResizeObserver.disconnect();
                }
                if (chartData.chart) {
                    chartData.chart.remove();
                }
                if (chartData.volumeChart) {
                    chartData.volumeChart.remove();
                }
            }

            // Remove tab and panel
            document.getElementById(`tab-${symbol}`).remove();
            document.getElementById(`panel-${symbol}`).remove();

            // Remove from state
            state.charts.delete(symbol);

            // Activate another chart if available
            if (state.charts.size > 0) {
                const firstSymbol = state.charts.keys().next().value;
                activateChart(firstSymbol);
            } else {
                // Show welcome message if no charts
                document.getElementById('welcomeMessage').style.display = 'block';
                state.activeChart = null;
            }
        }

        // Tab drag-and-drop handlers
        let draggedTab = null;

        function handleTabDragStart(e) {
            draggedTab = e.target.closest('.tab');
            if (draggedTab) {
                draggedTab.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', draggedTab.innerHTML);
            }
        }

        function handleTabDragEnd(e) {
            const tab = e.target.closest('.tab');
            if (tab) {
                tab.classList.remove('dragging');
            }
            // Remove drag-over class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('drag-over');
            });
        }

        function handleTabDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            const targetTab = e.target.closest('.tab');
            if (targetTab && targetTab !== draggedTab) {
                // Remove drag-over from all tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('drag-over');
                });
                // Add drag-over to target
                targetTab.classList.add('drag-over');
            }

            return false;
        }

        function handleTabDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            const targetTab = e.target.closest('.tab');
            if (draggedTab !== targetTab && targetTab) {
                const tabBar = document.getElementById('tabBar');
                const allTabs = Array.from(tabBar.children);
                const draggedIndex = allTabs.indexOf(draggedTab);
                const targetIndex = allTabs.indexOf(targetTab);

                if (draggedIndex < targetIndex) {
                    tabBar.insertBefore(draggedTab, targetTab.nextSibling);
                } else {
                    tabBar.insertBefore(draggedTab, targetTab);
                }
            }

            return false;
        }

        function handleTabDragLeave(e) {
            e.target.closest('.tab')?.classList.remove('drag-over');
        }

        // Control functions
        function setChartInterval(symbol, interval) {
            const panel = document.getElementById(`panel-${symbol}`);
            if (!panel) return;

            panel.querySelectorAll('.control-group:nth-child(1) .control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            const chartData = state.charts.get(symbol);
            chartData.interval = interval;

            // Update the refresh interval based on new chart interval
            if (state.updateIntervals.has(symbol)) {
                clearInterval(state.updateIntervals.get(symbol));

                // Adaptive refresh rate based on interval
                const getRefreshInterval = (interval) => {
                    switch(interval) {
                        case '1m': return 30000;  // 30 seconds for 1-minute charts
                        case '5m': return 30000;  // 30 seconds for 5-minute charts
                        case '30m': return 30000; // 30 seconds for 30-minute charts
                        case '1h': return 60000;  // 60 seconds for hourly charts
                        case '1d': return 60000;  // 60 seconds for daily charts
                        default: return 30000;    // Default 30 seconds
                    }
                };

                const refreshInterval = getRefreshInterval(interval);
                console.log(`Updated refresh interval for ${symbol} (${interval}): ${refreshInterval}ms`);
                const updateInterval = setInterval(() => loadChartData(symbol), refreshInterval);
                state.updateIntervals.set(symbol, updateInterval);
            }

            loadChartData(symbol);
        }

        function setRange(symbol, range) {
            const panel = document.getElementById(`panel-${symbol}`);
            if (!panel) return;

            // Update button active states
            panel.querySelectorAll('.control-group:nth-child(2) .control-btn').forEach(btn => {
                btn.classList.remove('active');
                const btnText = btn.textContent;
                if ((btnText === '1D' && range === '1d') ||
                    (btnText === '5D' && range === '5d') ||
                    (btnText === '1M' && range === '1mo') ||
                    (btnText === '1Y' && range === '1y')) {
                    btn.classList.add('active');
                }
            });

            const chartData = state.charts.get(symbol);
            chartData.range = range;

            // Enable/disable VWAP based on range (only valid for 1D charts)
            const vwapCheckbox = document.getElementById(`vwap-checkbox-${symbol}`);
            const vwapLabel = document.getElementById(`vwap-label-${symbol}`);
            if (vwapCheckbox && vwapLabel) {
                if (range !== '1d') {
                    // Disable VWAP for non-1D ranges
                    vwapCheckbox.disabled = true;
                    vwapCheckbox.checked = false;
                    vwapLabel.style.opacity = '0.5';
                    chartData.indicators.vwap = false;
                } else {
                    // Enable VWAP for 1D range
                    vwapCheckbox.disabled = false;
                    vwapLabel.style.opacity = '1';
                }
            }

            // Force chart recreation when range changes to properly display new time scale
            chartData.forceRecreate = true;
            loadChartData(symbol);
        }

        function toggleIndicator(symbol, indicator, enabled) {
            const chartData = state.charts.get(symbol);
            chartData.indicators[indicator] = enabled;
            // Force chart recreation when indicators change
            chartData.forceRecreate = true;
            loadChartData(symbol);
        }

        // Save chart settings to localStorage (global for all symbols)
        function saveChartSettings(symbol) {
            const chartData = state.charts.get(symbol);
            if (!chartData) return;

            const settings = {
                interval: chartData.interval,
                range: chartData.range,
                indicators: chartData.indicators,
                savedAt: new Date().toISOString()
            };

            // Save to localStorage with global key (not symbol-specific)
            localStorage.setItem('chart_settings_global', JSON.stringify(settings));

            console.log('Saved global chart settings:', settings);

            // Visual feedback - flash all save buttons
            document.querySelectorAll('.save-settings-btn').forEach(btn => {
                btn.classList.add('saved');
            });
            setTimeout(() => {
                document.querySelectorAll('.save-settings-btn').forEach(btn => {
                    btn.classList.remove('saved');
                });
            }, 1000);

            updateStatus('Saved', 'Chart settings saved for all symbols');
        }

        // Load chart settings from localStorage (global for all symbols)
        function loadChartSettings() {
            try {
                const savedSettings = localStorage.getItem('chart_settings_global');
                if (!savedSettings) {
                    console.log('No saved global settings found');
                    return null;
                }

                const settings = JSON.parse(savedSettings);
                console.log('Loaded global chart settings:', settings);
                return settings;
            } catch (error) {
                console.error('Error loading global settings:', error);
                return null;
            }
        }

        // Apply saved settings to chart
        function applyChartSettings(symbol, settings) {
            if (!settings) return;

            const panel = document.getElementById(`panel-${symbol}`);
            if (!panel) return;

            const chartData = state.charts.get(symbol);
            if (!chartData) return;

            // Apply interval
            if (settings.interval) {
                chartData.interval = settings.interval;
                panel.querySelectorAll('.control-group:nth-child(1) .control-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.textContent === settings.interval) {
                        btn.classList.add('active');
                    }
                });
            }

            // Apply range
            if (settings.range) {
                chartData.range = settings.range;
                panel.querySelectorAll('.control-group:nth-child(2) .control-btn').forEach(btn => {
                    btn.classList.remove('active');
                    const btnText = btn.textContent;
                    if (btnText === settings.range ||
                        (btnText === '1D' && settings.range === '1d') ||
                        (btnText === '5D' && settings.range === '5d') ||
                        (btnText === '1M' && settings.range === '1mo') ||
                        (btnText === '1Y' && settings.range === '1y')) {
                        btn.classList.add('active');
                    }
                });
            }

            // Apply indicators
            if (settings.indicators) {
                chartData.indicators = { ...settings.indicators };

                // Disable VWAP if range is not 1D
                if (chartData.range !== '1d') {
                    chartData.indicators.vwap = false;
                }

                // Update checkboxes using their IDs
                Object.keys(settings.indicators).forEach(indicator => {
                    const checkbox = document.getElementById(`${indicator}-checkbox-${symbol}`);
                    if (checkbox) {
                        checkbox.checked = settings.indicators[indicator];
                    }
                });

                // Disable VWAP checkbox/label if not 1D range
                const vwapCheckbox = document.getElementById(`vwap-checkbox-${symbol}`);
                const vwapLabel = document.getElementById(`vwap-label-${symbol}`);
                if (vwapCheckbox && vwapLabel && chartData.range !== '1d') {
                    vwapCheckbox.disabled = true;
                    vwapCheckbox.checked = false;
                    vwapLabel.style.opacity = '0.5';
                }
            }

            console.log(`Applied settings for ${symbol}`);
        }

        // Load chart data from backend
        async function loadChartData(symbol) {
            const chartData = state.charts.get(symbol);
            if (!chartData) {
                console.error('Chart data not found for symbol:', symbol);
                return;
            }

            try {
                updateStatus('Loading', `Fetching data for ${symbol}...`);

                // Build API URL
                const indicators = Object.keys(chartData.indicators)
                    .filter(key => chartData.indicators[key])
                    .join(',');

                const apiUrl = `./cgi-bin/api/market_data_api.py?action=chart&symbol=${symbol}&interval=${chartData.interval}&range=${chartData.range}&indicators=${indicators}`;
                console.log('Loading chart from:', apiUrl);

                // Fetch data from backend API
                const response = await fetch(apiUrl);
                const result = await response.json();

                console.log('Chart response:', result);

                if (!result.success) {
                    throw new Error(result.error || 'Failed to fetch chart data');
                }

                const data = result.data;

                if (!data.bars || data.bars.length === 0) {
                    throw new Error('No chart data available');
                }

                console.log(`Processing ${data.bars.length} bars for chart`);
                console.log('Sample raw bar data:', data.bars[0]);

                // Convert bar data to candlestick format for TradingView Lightweight Charts
                // Note: Timestamps from API are already in Eastern Time (ET) with timezone info
                // Example: "2025-10-27T04:00:00-04:00" (4:00 AM EDT)
                //
                // IMPORTANT: TradingView charts display timestamps in UTC, so we need to convert
                // ET time components to a "fake" UTC timestamp that displays the correct ET time
                const candlesticks = data.bars.map(bar => {
                    const timestamp = bar.timestamp;
                    const date = new Date(timestamp);

                    // Extract date/time components in ET timezone
                    const etDateString = date.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });

                    // Parse the ET string (format: "MM/DD/YYYY, HH:mm:ss")
                    const [datePart, timePart] = etDateString.split(', ');
                    const [month, day, year] = datePart.split('/');
                    const [hour, minute, second] = timePart.split(':');

                    // Create Unix timestamp treating ET components as UTC
                    // This makes the chart display ET times correctly
                    const unixTime = Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);

                    // Debug first bar conversion
                    if (bar === data.bars[0]) {
                        console.log('First bar conversion:', {
                            raw_timestamp: timestamp,
                            et_string: etDateString,
                            unix_seconds: unixTime,
                            display_time: new Date(unixTime * 1000).toISOString()
                        });
                    }

                    return {
                        time: unixTime,
                        open: bar.open,
                        high: bar.high,
                        low: bar.low,
                        close: bar.close
                    };
                });

                console.log('Candlesticks prepared:', candlesticks.length);
                console.log('First candlestick:', candlesticks[0]);
                console.log('Last candlestick:', candlesticks[candlesticks.length - 1]);

                // Convert volume timestamps using the same ET timezone conversion
                // Color volume bars based on whether the bar closed up (green) or down (red)
                const volume = data.bars.map(bar => {
                    const date = new Date(bar.timestamp);
                    const etDateString = date.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    const [datePart, timePart] = etDateString.split(', ');
                    const [month, day, year] = datePart.split('/');
                    const [hour, minute, second] = timePart.split(':');
                    const unixTime = Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);

                    // Determine color: green if close >= open, red if close < open
                    const color = bar.close >= bar.open ? '#4ecca3' : '#ff6b6b';

                    return {
                        time: unixTime,
                        value: bar.volume,
                        color: color
                    };
                });

                renderChart(symbol, {
                    candlesticks,
                    indicators: data.indicators || {},
                    volume: volume
                });

                updateStatus('Connected', `${symbol} updated`);
                document.getElementById('updateTime').textContent =
                    `Last updated: ${new Date().toLocaleTimeString()}`;

            } catch (error) {
                console.error('Error loading chart data:', error);
                updateStatus('Error', `Failed to load data for ${symbol}: ${error.message}`);
            }
        }

        // Render chart
        function renderChart(symbol, data) {
            console.log('renderChart called for', symbol, 'with', data.candlesticks.length, 'candlesticks');

            const canvasContainer = document.getElementById(`canvas-${symbol}`);
            if (!canvasContainer) {
                console.error('Canvas container not found for', symbol);
                return;
            }

            const loading = canvasContainer.previousElementSibling;
            if (loading) {
                loading.classList.remove('active');
            }
            canvasContainer.style.display = 'block';

            const chartElement = document.getElementById(`chart-${symbol}`);
            if (!chartElement) {
                console.error('Chart element not found for', symbol);
                return;
            }

            const chartData = state.charts.get(symbol);
            if (!chartData) {
                console.error('Chart data state not found for', symbol);
                return;
            }

            // If chart already exists, just update the data instead of destroying/recreating
            // (unless indicators changed, which requires recreation)
            if (chartData.chart && chartData.candlestickSeries && !chartData.forceRecreate) {
                console.log('Updating existing chart with new data');

                // Update candlestick data
                chartData.candlestickSeries.setData(data.candlesticks);

                // Update legend with latest bar
                if (data.candlesticks.length > 0) {
                    const latestBar = data.candlesticks[data.candlesticks.length - 1];
                    updateLegendWithBar(symbol, latestBar);
                }

                // Helper function to convert timestamps
                function convertTimestampToET(timestamp) {
                    const date = new Date(timestamp);
                    const etDateString = date.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    const [datePart, timePart] = etDateString.split(', ');
                    const [month, day, year] = datePart.split('/');
                    const [hour, minute, second] = timePart.split(':');
                    return Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);
                }

                // Update indicators
                const indicators = data.indicators || {};

                // Update EMA indicators
                if (chartData.indicatorSeries.ema9 && indicators.ema9) {
                    const ema9Data = indicators.ema9
                        .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                        .map(item => ({
                            time: convertTimestampToET(item.time),
                            value: item.value
                        }));
                    chartData.indicatorSeries.ema9.setData(ema9Data);
                }

                if (chartData.indicatorSeries.ema21 && indicators.ema21) {
                    const ema21Data = indicators.ema21
                        .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                        .map(item => ({
                            time: convertTimestampToET(item.time),
                            value: item.value
                        }));
                    chartData.indicatorSeries.ema21.setData(ema21Data);
                }

                if (chartData.indicatorSeries.ema50 && indicators.ema50) {
                    const ema50Data = indicators.ema50
                        .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                        .map(item => ({
                            time: convertTimestampToET(item.time),
                            value: item.value
                        }));
                    chartData.indicatorSeries.ema50.setData(ema50Data);
                }

                if (chartData.indicatorSeries.vwap && indicators.vwap) {
                    const vwapData = indicators.vwap
                        .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                        .map(item => ({
                            time: convertTimestampToET(item.time),
                            value: item.value
                        }));
                    chartData.indicatorSeries.vwap.setData(vwapData);
                }

                // Update volume chart
                if (chartData.indicatorSeries.volume && data.volume) {
                    chartData.indicatorSeries.volume.setData(data.volume);
                    chartData.volumeData = data.volume;  // Store volume data for float rotation calculation
                }

                // Update float rotation in legend after volume data updates
                updateLegendFloatRotation(symbol);

                console.log('Chart data updated without recreation');
                return;
            }

            // Chart doesn't exist yet, create it (or needs recreation due to indicator changes)
            if (chartData.chart) {
                console.log('Removing existing chart for recreation');

                // Clear the forceRecreate flag
                chartData.forceRecreate = false;

                // Save current zoom/pan state before destroying chart
                try {
                    const currentRange = chartData.chart.timeScale().getVisibleLogicalRange();
                    if (currentRange) {
                        chartData.savedZoomState = currentRange;
                        console.log('Saved zoom state:', currentRange);
                    }
                } catch (error) {
                    console.warn('Could not save zoom state:', error);
                }

                if (chartData.resizeObserver) {
                    chartData.resizeObserver.disconnect();
                    chartData.resizeObserver = null;
                }
                if (chartData.volumeResizeObserver) {
                    chartData.volumeResizeObserver.disconnect();
                    chartData.volumeResizeObserver = null;
                }
                chartData.chart.remove();
                chartData.chart = null;
                if (chartData.volumeChart) {
                    chartData.volumeChart.remove();
                    chartData.volumeChart = null;
                }
            }

            // Wait for layout to complete before creating chart
            // This fixes the "chart appears then disappears" bug caused by 0x0 dimensions
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    createChart(chartElement, chartData, symbol, data);
                });
            });
        }

        // Create the actual chart (separated to handle async layout)
        function createChart(chartElement, chartData, symbol, data) {
            console.log('=== CREATE CHART CALLED ===');
            console.log('Chart element dimensions:', chartElement.clientWidth, 'x', chartElement.clientHeight);
            console.log('Candlesticks to render:', data.candlesticks.length);
            console.log('First 3 candlesticks:', data.candlesticks.slice(0, 3));

            // Check if element has dimensions
            if (chartElement.clientWidth === 0 || chartElement.clientHeight === 0) {
                console.error('Chart element has zero dimensions! Cannot create chart.');
                // Try again after a short delay
                setTimeout(() => {
                    console.log('Retrying chart creation after delay...');
                    createChart(chartElement, chartData, symbol, data);
                }, 100);
                return;
            }

            // Create new Lightweight Charts instance
            console.log('=== CREATING MAIN CHART ===');
            console.log('Main chart element ID:', chartElement.id);
            console.log('Main chart dimensions:', chartElement.clientWidth, 'x', chartElement.clientHeight);
            const chart = LightweightCharts.createChart(chartElement, {
                width: chartElement.clientWidth,
                height: chartElement.clientHeight,
                layout: {
                    background: { color: '#1a1a2e' },
                    textColor: '#d1d4dc',  // Brighter text for better visibility
                },
                grid: {
                    vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                    horzLines: { color: 'rgba(255, 255, 255, 0.1)' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 255, 255, 0.2)',
                    width: 75,  // Fixed width for alignment
                    minimumWidth: 75,
                },
                timeScale: {
                    borderColor: 'rgba(255, 255, 255, 0.8)',  // Much brighter border
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            // Force timeScale to be visible with bright colors
            console.log('Forcing timeScale visibility...');
            chart.applyOptions({
                layout: {
                    textColor: '#ffffff',  // Pure white for maximum visibility
                },
                timeScale: {
                    visible: true,
                    timeVisible: true,
                    secondsVisible: false,
                    borderColor: '#ffffff',  // Pure white border
                }
            });
            const timeScale = chart.timeScale();
            console.log('TimeScale object:', timeScale);
            console.log('Full TimeScale options:', timeScale.options());

            // Add candlestick series
            console.log('Adding candlestick series...');
            const candlestickSeries = chart.addCandlestickSeries({
                upColor: '#4ecca3',
                downColor: '#ff6b6b',
                borderVisible: false,
                wickUpColor: '#4ecca3',
                wickDownColor: '#ff6b6b',
                lastValueVisible: false,  // Hide price label on right side
                priceLineVisible: false   // Hide horizontal price line
            });

            // Set the candlestick data
            console.log('Setting candlestick data:', data.candlesticks.length, 'bars');
            if (data.candlesticks.length > 0) {
                console.log('First bar:', data.candlesticks[0]);
                console.log('Last bar:', data.candlesticks[data.candlesticks.length - 1]);
            }
            candlestickSeries.setData(data.candlesticks);
            console.log('Candlestick data set successfully');

            // Store chart reference
            chartData.chart = chart;
            chartData.candlestickSeries = candlestickSeries;
            chartData.indicatorSeries = {};

            // Update legend on crosshair move
            chart.subscribeCrosshairMove((param) => {
                updateLegend(symbol, param, candlestickSeries, data.candlesticks, chartData);
            });

            // Initialize legend with latest bar
            if (data.candlesticks.length > 0) {
                const latestBar = data.candlesticks[data.candlesticks.length - 1];
                updateLegendWithBar(symbol, latestBar);
            }

            // Helper function to convert timestamps from ET to display correctly in UTC charts
            function convertTimestampToET(timestamp) {
                const date = new Date(timestamp);
                const etDateString = date.toLocaleString('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                const [datePart, timePart] = etDateString.split(', ');
                const [month, day, year] = datePart.split('/');
                const [hour, minute, second] = timePart.split(':');
                return Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);
            }

            // Add indicator series if available
            const indicators = data.indicators || {};

            // EMA indicators
            if (indicators.ema9 && indicators.ema9.length > 0) {
                const ema9Series = chart.addLineSeries({
                    color: '#2962FF',
                    lineWidth: 2,
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const ema9Data = indicators.ema9
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                console.log(`EMA(9): Filtered ${indicators.ema9.length} -> ${ema9Data.length} data points`);
                if (ema9Data.length > 0) {
                    console.log('EMA(9) first/last values:', ema9Data[0].value, ema9Data[ema9Data.length-1].value);
                }
                ema9Series.setData(ema9Data);
                chartData.indicatorSeries.ema9 = ema9Series;
            }

            if (indicators.ema21 && indicators.ema21.length > 0) {
                const ema21Series = chart.addLineSeries({
                    color: '#FF6D00',
                    lineWidth: 2,
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const ema21Data = indicators.ema21
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                ema21Series.setData(ema21Data);
                chartData.indicatorSeries.ema21 = ema21Series;
            }

            if (indicators.ema50 && indicators.ema50.length > 0) {
                const ema50Series = chart.addLineSeries({
                    color: '#00E676',
                    lineWidth: 2,
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const ema50Data = indicators.ema50
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                ema50Series.setData(ema50Data);
                chartData.indicatorSeries.ema50 = ema50Series;
            }

            if (indicators.ema200 && indicators.ema200.length > 0) {
                const ema200Series = chart.addLineSeries({
                    color: '#D500F9',
                    lineWidth: 2,
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const ema200Data = indicators.ema200
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                ema200Series.setData(ema200Data);
                chartData.indicatorSeries.ema200 = ema200Series;
            }

            // VWAP indicator
            if (indicators.vwap && indicators.vwap.length > 0) {
                const vwapSeries = chart.addLineSeries({
                    color: '#FFD600',
                    lineWidth: 2,
                    lineStyle: 2, // Dashed line
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const vwapData = indicators.vwap
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                console.log(`VWAP: Filtered ${indicators.vwap.length} -> ${vwapData.length} data points`);
                if (vwapData.length > 0) {
                    console.log('VWAP first/last values:', vwapData[0].value, vwapData[vwapData.length-1].value);
                }
                vwapSeries.setData(vwapData);
                chartData.indicatorSeries.vwap = vwapSeries;
            }

            // Create separate volume chart
            if (chartData.indicators.volume && data.volume && data.volume.length > 0) {
                const volumeElement = document.getElementById(`volume-${symbol}`);
                if (volumeElement) {
                    console.log('=== CREATING VOLUME CHART ===');
                    console.log('Volume chart element ID:', volumeElement.id);
                    console.log('Volume chart dimensions:', volumeElement.clientWidth, 'x', volumeElement.clientHeight);
                    console.log('Volume element parent:', volumeElement.parentElement.id);

                    // Check if volume element has dimensions
                    if (volumeElement.clientWidth === 0 || volumeElement.clientHeight === 0) {
                        console.warn('Volume chart element has zero dimensions! Width:', volumeElement.clientWidth, 'Height:', volumeElement.clientHeight);
                        // Continue anyway - ResizeObserver will fix it when it gets dimensions
                    }

                    const volumeChart = LightweightCharts.createChart(volumeElement, {
                        width: volumeElement.clientWidth,
                        height: volumeElement.clientHeight,
                        layout: {
                            background: { color: '#1a1a2e' },
                            textColor: '#d1d4dc',
                        },
                        grid: {
                            vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                            horzLines: { color: 'rgba(255, 255, 255, 0.1)' },
                        },
                        rightPriceScale: {
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                            width: 75,  // Fixed width for alignment with main chart
                            minimumWidth: 75,
                        },
                        timeScale: {
                            borderColor: 'rgba(255, 255, 255, 0.8)',
                            timeVisible: true,
                            secondsVisible: false,
                        },
                    });

                    const volumeSeries = volumeChart.addHistogramSeries({
                        priceFormat: {
                            type: 'volume',
                        },
                        lastValueVisible: false,  // Hide volume label on right side
                        priceLineVisible: false   // Hide horizontal price line
                    });
                    volumeSeries.setData(data.volume);

                    // Store volume chart reference
                    chartData.volumeChart = volumeChart;
                    chartData.volumeSeries = volumeSeries;
                    chartData.volumeData = data.volume;  // Store volume data for float rotation calculation
                    chartData.indicatorSeries.volume = volumeSeries;

                    // Sync time scales between main chart and volume chart
                    // Use flags to prevent infinite loop
                    let syncingToVolume = false;
                    let syncingToMain = false;

                    chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                        if (syncingToMain) return;
                        const range = chart.timeScale().getVisibleLogicalRange();
                        if (range) {
                            syncingToVolume = true;
                            volumeChart.timeScale().setVisibleLogicalRange(range);
                            syncingToVolume = false;
                            // Save zoom state whenever user changes it
                            chartData.savedZoomState = range;
                        }
                    });

                    volumeChart.timeScale().subscribeVisibleTimeRangeChange(() => {
                        if (syncingToVolume) return;
                        const range = volumeChart.timeScale().getVisibleLogicalRange();
                        if (range) {
                            syncingToMain = true;
                            chart.timeScale().setVisibleLogicalRange(range);
                            syncingToMain = false;
                            // Save zoom state whenever user changes it
                            chartData.savedZoomState = range;
                        }
                    });

                    // Handle volume chart resize
                    const volumeResizeObserver = new ResizeObserver(entries => {
                        if (entries.length === 0) return;
                        const { width, height } = entries[0].contentRect;
                        volumeChart.applyOptions({ width, height });
                    });
                    volumeResizeObserver.observe(volumeElement);

                    // Store for cleanup
                    chartData.volumeResizeObserver = volumeResizeObserver;
                }
            } else {
                // If no volume chart, still track zoom state changes on main chart
                chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                    const range = chart.timeScale().getVisibleLogicalRange();
                    if (range) {
                        chartData.savedZoomState = range;
                    }
                });
            }

            // Handle window resize
            const resizeObserver = new ResizeObserver(entries => {
                if (entries.length === 0) return;
                const { width, height } = entries[0].contentRect;
                chart.applyOptions({ width, height });
            });
            resizeObserver.observe(chartElement);

            // Store resize observer for cleanup
            chartData.resizeObserver = resizeObserver;

            // Restore saved zoom state or set default view
            const barsCount = data.candlesticks.length;
            if (barsCount > 0) {
                if (chartData.savedZoomState) {
                    // Restore previous zoom/pan state
                    console.log('Restoring saved zoom state:', chartData.savedZoomState);
                    try {
                        chart.timeScale().setVisibleLogicalRange(chartData.savedZoomState);
                        console.log('Zoom state restored successfully');
                    } catch (error) {
                        console.warn('Could not restore zoom state, using default:', error);
                        // Fall back to default view
                        const visibleBars = Math.min(100, barsCount);
                        chart.timeScale().setVisibleLogicalRange({
                            from: barsCount - visibleBars,
                            to: barsCount - 1
                        });
                    }
                } else {
                    // Show last 100 bars (or all bars if less than 100) for new charts
                    const visibleBars = Math.min(100, barsCount);
                    chart.timeScale().setVisibleLogicalRange({
                        from: barsCount - visibleBars,
                        to: barsCount - 1
                    });
                    console.log('TimeScale set to show bars', barsCount - visibleBars, 'to', barsCount - 1);
                }
                console.log('TimeScale options:', chart.timeScale().options());
            }

            // Debug: Check if chart is actually visible in DOM
            console.log('Chart element parent dimensions:', chartElement.parentElement.clientWidth, 'x', chartElement.parentElement.clientHeight);
            console.log('Chart element computed style:', window.getComputedStyle(chartElement).display);

            // Check if timeScale element exists in DOM
            setTimeout(() => {
                const allTables = chartElement.querySelectorAll('table');
                console.log('Found', allTables.length, 'table elements in chart');

                if (allTables.length > 0) {
                    const table = allTables[0];
                    const rows = table.querySelectorAll('tr');
                    console.log('Found', rows.length, 'table rows');

                    if (rows.length > 1) {
                        console.log('Row 0 (main chart) height:', rows[0].querySelector('td')?.style.height);
                        console.log('Row 1 (timeScale) height:', rows[1].querySelector('td')?.style.height);

                        // Check the canvas in the timeScale row
                        const timeScaleCanvas = rows[1].querySelector('canvas');
                        if (timeScaleCanvas) {
                            console.log('TimeScale canvas found! Dimensions:', timeScaleCanvas.width, 'x', timeScaleCanvas.height);
                            console.log('TimeScale canvas style:', timeScaleCanvas.style.cssText);
                        } else {
                            console.log('No canvas found in timeScale row!');
                        }
                    }
                }
            }, 500);

            // Update float rotation in legend after chart is fully rendered
            updateLegendFloatRotation(symbol);
        }


        // Render time and sales
        function renderTimeSales(symbol, trades) {
            const container = document.getElementById(`trades-${symbol}`);
            const chartData = state.charts.get(symbol);

            if (!container || !chartData) {
                console.error('Cannot render trades - container or chartData missing');
                return;
            }

            console.log(`Rendering ${trades.length} trades for ${symbol}`);

            // Debug: Log first and last trade timestamps
            if (trades.length > 0) {
                const now = new Date();
                const oldestTrade = new Date(trades[0].timestamp);
                const newestTrade = new Date(trades[trades.length - 1].timestamp);
                const ageMinutes = Math.round((now - newestTrade) / 1000 / 60);
                console.log(`Trade age: Most recent trade is ${ageMinutes} minutes old`);
                console.log(`Oldest trade: ${oldestTrade.toISOString()}`);
                console.log(`Newest trade: ${newestTrade.toISOString()}`);
                console.log(`Current time: ${now.toISOString()}`);
            }

            // Map trades with price comparison to PREVIOUS trade in chronological order
            const tradeItems = trades.map((trade, index) => {
                // Compare to previous trade in time sequence (not display sequence)
                const prevPrice = index > 0 ? trades[index - 1].price : null;
                const priceClass = prevPrice && trade.price > prevPrice ? 'up' :
                                  prevPrice && trade.price < prevPrice ? 'down' : '';

                // Format time in ET timezone (backend returns ISO strings with ET offset)
                const tradeDate = new Date(trade.timestamp);
                const tradeTime = tradeDate.toLocaleTimeString('en-US', {
                    timeZone: 'America/New_York',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });

                // Get exchange name and symbol
                const exchangeName = getExchangeName(trade.exchange);
                const symbolDisplay = trade.symbol || 'UNK';

                return `
                    <div class="trade-item ${priceClass}">
                        <div>
                            <div class="trade-time">${tradeTime} ET</div>
                            <div class="trade-price ${priceClass}">$${trade.price.toFixed(2)}</div>
                            <div class="trade-time" style="margin-top: 2px;">${symbolDisplay} - ${exchangeName}</div>
                        </div>
                        <div class="trade-size">${trade.size.toLocaleString()}</div>
                    </div>
                `;
            });

            // Reverse so newest trades appear at the top
            container.innerHTML = tradeItems.reverse().join('');

            if (trades.length > 0) {
                // Use the most recent trade (last in original array, first in reversed)
                chartData.lastPrice = trades[trades.length - 1].price;
            }


            // Auto-scroll to top to show newest trades
            container.scrollTop = 0;
        }

        // Update status bar
        function updateStatus(status, message) {
            document.getElementById('statusText').textContent = `${status}: ${message}`;
        }

        // Update legend with bar data
        function updateLegendWithBar(symbol, bar, indicatorValues, volumeValue) {
            const priceElement = document.getElementById(`legend-price-${symbol}`);
            const detailsElement = document.getElementById(`legend-details-${symbol}`);
            const volumeElement = document.getElementById(`legend-volume-${symbol}`);
            const symbolElement = document.querySelector(`#legend-${symbol} .legend-symbol`);

            if (!priceElement || !detailsElement) return;

            // Update symbol display with company name if available
            const chartData = state.charts.get(symbol);
            if (symbolElement && chartData && chartData.companyName) {
                symbolElement.textContent = `${symbol} - ${chartData.companyName}`;
            }

            const isUp = bar.close >= bar.open;
            const change = bar.close - bar.open;
            const changePercent = bar.open > 0 ? (change / bar.open * 100) : 0;

            priceElement.className = `legend-price ${isUp ? 'up' : 'down'}`;
            priceElement.innerHTML = `$${bar.close.toFixed(2)} <span class="legend-change">${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)</span>`;

            detailsElement.textContent = `O: $${bar.open.toFixed(2)} H: $${bar.high.toFixed(2)} L: $${bar.low.toFixed(2)} C: $${bar.close.toFixed(2)}`;

            // Update volume in legend
            if (volumeElement && volumeValue !== undefined && volumeValue !== null) {
                const formattedVolume = volumeValue.toLocaleString();
                volumeElement.innerHTML = `Vol: <span class="legend-volume-value">${formattedVolume}</span>`;
            }

            // Update indicator values in legend
            if (indicatorValues) {
                updateLegendIndicators(symbol, indicatorValues);
            }
        }

        // Update indicator values in legend
        function updateLegendIndicators(symbol, indicatorValues) {
            const indicatorsElement = document.getElementById(`legend-indicators-${symbol}`);
            if (!indicatorsElement) return;

            const indicatorConfigs = {
                ema9: { label: 'EMA(9)', color: '#2962FF' },
                ema21: { label: 'EMA(21)', color: '#FF6D00' },
                ema50: { label: 'EMA(50)', color: '#00E676' },
                ema200: { label: 'EMA(200)', color: '#D500F9' },
                vwap: { label: 'VWAP', color: '#FFD600' }
            };

            let html = '';
            for (const [key, config] of Object.entries(indicatorConfigs)) {
                if (indicatorValues[key] !== undefined && indicatorValues[key] !== null) {
                    html += `
                        <div class="legend-indicator-item">
                            <span class="legend-indicator-color" style="background-color: ${config.color};"></span>
                            <span class="legend-indicator-label">${config.label}:</span>
                            <span class="legend-indicator-value">$${indicatorValues[key].toFixed(2)}</span>
                        </div>
                    `;
                }
            }

            indicatorsElement.innerHTML = html;
        }

        // Update legend on crosshair move
        function updateLegend(symbol, param, candlestickSeries, candlesticks, chartData) {
            if (!param.time) {
                // No bar under crosshair, show latest bar
                if (candlesticks.length > 0) {
                    const latestBar = candlesticks[candlesticks.length - 1];
                    const indicatorValues = getLatestIndicatorValues(chartData);
                    updateLegendWithBar(symbol, latestBar, indicatorValues);
                }
                return;
            }

            const data = param.seriesData.get(candlestickSeries);
            if (data) {
                // Get indicator values at crosshair position
                const indicatorValues = {};
                let volumeValue = null;

                if (chartData && chartData.indicatorSeries) {
                    for (const [key, series] of Object.entries(chartData.indicatorSeries)) {
                        if (series && param.seriesData.has(series)) {
                            const value = param.seriesData.get(series);
                            if (value && value.value !== undefined) {
                                if (key === 'volume') {
                                    volumeValue = value.value;
                                } else {
                                    indicatorValues[key] = value.value;
                                }
                            }
                        }
                    }
                }
                updateLegendWithBar(symbol, data, indicatorValues, volumeValue);
            }
        }

        // Get latest indicator values
        function getLatestIndicatorValues(chartData) {
            const values = {};
            if (!chartData || !chartData.indicatorSeries) return values;

            // This will be populated when indicators update
            // For now, we'll get values from crosshair events
            return values;
        }

        // Mock data generators (to be replaced with backend calls)
        function generateMockData(symbol, interval, range) {
            const candlesticks = [];
            const numBars = range === '1d' ? 390 : range === '5d' ? 1950 : 100;
            let basePrice = 150 + Math.random() * 50;

            for (let i = 0; i < numBars; i++) {
                // Lightweight Charts requires Unix timestamp in SECONDS (not milliseconds)
                const timeMs = Date.now() - (numBars - i) * 60000;
                const time = Math.floor(timeMs / 1000);

                const open = basePrice;
                const close = basePrice + (Math.random() - 0.5) * 5;
                const high = Math.max(open, close) + Math.random() * 2;
                const low = Math.min(open, close) - Math.random() * 2;

                candlesticks.push({
                    time: time,
                    open: Number(open.toFixed(2)),
                    high: Number(high.toFixed(2)),
                    low: Number(low.toFixed(2)),
                    close: Number(close.toFixed(2))
                });

                basePrice = close;
            }

            return { candlesticks };
        }

        function generateMockTrades(symbol) {
            const trades = [];
            let basePrice = 150 + Math.random() * 50;

            for (let i = 0; i < 20; i++) {
                const price = basePrice + (Math.random() - 0.5) * 2;
                trades.push({
                    timestamp: new Date(Date.now() - (20 - i) * 5000),
                    price: price,
                    size: Math.floor(Math.random() * 1000) + 100
                });
                basePrice = price;
            }

            return trades.reverse();
        }

        // ========================================
        // PREMARKET POPUP FUNCTIONALITY
        // ========================================

        // Premarket data state
        const premarketState = {
            data: [],
            sortColumn: 'gain_percent',
            sortDirection: 'desc'
        };

        function openPremarketPopup() {
            const popup = document.getElementById('premarketPopup');
            popup.style.display = 'block';
            loadPremarketData();
        }

        function closePremarketPopup() {
            const popup = document.getElementById('premarketPopup');
            popup.style.display = 'none';
        }

        // ==================== Fundamentals Popup Functions ====================

        function openFundamentalsPopup() {
            const popup = document.getElementById('fundamentalsPopup');
            popup.style.display = 'flex';
            // Focus on input field
            document.getElementById('fundamentalsSymbolInput').focus();
        }

        function closeFundamentalsPopup() {
            const popup = document.getElementById('fundamentalsPopup');
            popup.style.display = 'none';
            // Reset popup
            document.getElementById('fundamentalsSymbolInput').value = '';
            document.getElementById('fundamentalsPopupData').style.display = 'none';
            document.getElementById('fundamentalsPopupData').innerHTML = '';
        }

        function handleFundamentalsKeypress(event) {
            if (event.key === 'Enter') {
                fetchFundamentalsForPopup();
            }
        }

        async function fetchFundamentalsForPopup() {
            const input = document.getElementById('fundamentalsSymbolInput');
            const symbol = input.value.trim().toUpperCase();
            const dataDiv = document.getElementById('fundamentalsPopupData');
            const fetchBtn = document.querySelector('.fundamentals-fetch-btn');

            if (!symbol) {
                alert('Please enter a stock symbol');
                return;
            }

            try {
                // Disable button and show loading
                fetchBtn.disabled = true;
                fetchBtn.textContent = 'Loading...';
                dataDiv.style.display = 'block';
                dataDiv.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">Loading fundamentals...</div>';

                const response = await fetch(`cgi-bin/api/stock_fundamentals_api.py?symbol=${symbol}`);
                const data = await response.json();

                if (data.success) {
                    displayPopupFundamentals(symbol, data);
                } else {
                    dataDiv.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 20px;">Error: ${data.error || 'Failed to load fundamentals'}</div>`;
                }
            } catch (error) {
                console.error('Error fetching fundamentals:', error);
                dataDiv.innerHTML = `<div style="color: var(--accent-red); text-align: center; padding: 20px;">Error: ${error.message}</div>`;
            } finally {
                // Re-enable button
                fetchBtn.disabled = false;
                fetchBtn.textContent = 'Get Fundamentals';
            }
        }

        function displayPopupFundamentals(symbol, data) {
            const dataDiv = document.getElementById('fundamentalsPopupData');

            dataDiv.innerHTML = `
                <h3>${symbol}${data.company_name ? ' - ' + data.company_name : ''}</h3>
                <div class="fundamentals-popup-item">
                    <span class="fundamentals-popup-label">Market Cap:</span>
                    <span class="fundamentals-popup-value">${data.market_cap_formatted}</span>
                </div>
                <div class="fundamentals-popup-item">
                    <span class="fundamentals-popup-label">Shares Outstanding:</span>
                    <span class="fundamentals-popup-value">${data.shares_outstanding_formatted}</span>
                </div>
                <div class="fundamentals-popup-item">
                    <span class="fundamentals-popup-label">Float Shares:</span>
                    <span class="fundamentals-popup-value">${data.float_shares_formatted}</span>
                </div>
                <div class="fundamentals-popup-item">
                    <span class="fundamentals-popup-label">Float Rotation (Today):</span>
                    <span class="fundamentals-popup-value">${data.float_rotation_formatted || 'N/A'}</span>
                </div>
                ${data.todays_volume_formatted && data.todays_volume_formatted !== 'N/A' ? `
                <div class="fundamentals-popup-item">
                    <span class="fundamentals-popup-label">Volume (Today):</span>
                    <span class="fundamentals-popup-value">${data.todays_volume_formatted}</span>
                </div>
                ` : ''}
                ${data.sector !== 'N/A' ? `
                <div class="fundamentals-popup-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                    <span class="fundamentals-popup-label">Sector:</span>
                    <span class="fundamentals-popup-value">${data.sector}</span>
                </div>
                ` : ''}
                ${data.industry !== 'N/A' ? `
                <div class="fundamentals-popup-item">
                    <span class="fundamentals-popup-label">Industry:</span>
                    <span class="fundamentals-popup-value">${data.industry}</span>
                </div>
                ` : ''}
            `;
        }

        // Close popup when clicking outside of it
        window.onclick = function(event) {
            const premarketPopup = document.getElementById('premarketPopup');
            const fundamentalsPopup = document.getElementById('fundamentalsPopup');

            if (event.target === premarketPopup) {
                closePremarketPopup();
            }

            if (event.target === fundamentalsPopup) {
                closeFundamentalsPopup();
            }
        }

        async function loadPremarketData() {
            const loadingDiv = document.getElementById('premarketLoading');
            const errorDiv = document.getElementById('premarketError');
            const tableContainer = document.getElementById('premarketTableContainer');

            // Show loading state
            loadingDiv.style.display = 'block';
            errorDiv.style.display = 'none';
            tableContainer.style.display = 'none';

            try {
                // Get today's date in YYYY-MM-DD format (ET timezone)
                const today = new Date().toLocaleDateString('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                }).split('/');
                const dateStr = `${today[2]}-${today[0]}-${today[1]}`;

                const csvPath = `historical_data/${dateStr}/premarket/top_gainers_nasdaq_amex.csv`;

                console.log('Loading premarket CSV from:', csvPath);

                const response = await fetch(csvPath);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const csvText = await response.text();

                // Parse CSV
                premarketState.data = parsePremarketCSV(csvText);

                if (premarketState.data.length === 0) {
                    throw new Error('No data found in CSV file');
                }

                // Sort by gain% descending (default)
                sortPremarketData('gain_percent', 'desc');

                // Render table
                renderPremarketTable();

                // Hide loading, show table
                loadingDiv.style.display = 'none';
                tableContainer.style.display = 'block';

            } catch (error) {
                console.error('Error loading premarket data:', error);
                loadingDiv.style.display = 'none';
                errorDiv.textContent = `Error loading data: ${error.message}`;
                errorDiv.style.display = 'block';
            }
        }

        function parsePremarketCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length === 0) return [];

            // Get headers
            const headers = lines[0].split(',').map(h => h.trim());

            // Parse data rows
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length < headers.length) continue;

                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] ? values[index].trim() : '';
                });

                // Convert numeric fields
                row.prev_close = parseFloat(row.previous_close || row.prev_close) || 0;
                row.current_price = parseFloat(row.current_price || row.premarket_price) || 0;
                row.gain_percent = parseFloat(row.gain_percent) || 0;
                row.pm_volume = parseInt(row.premarket_volume || row.pm_volume) || 0;
                row.pm_range = parseFloat(row.premarket_range || row.pm_range) || 0;

                data.push(row);
            }

            return data;
        }

        function sortPremarketTable(column) {
            if (premarketState.sortColumn === column) {
                // Toggle direction
                premarketState.sortDirection = premarketState.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // New column, default to descending for numeric columns, ascending for text
                premarketState.sortColumn = column;
                premarketState.sortDirection = column === 'symbol' ? 'asc' : 'desc';
            }

            sortPremarketData(column, premarketState.sortDirection);
            renderPremarketTable();
        }

        function sortPremarketData(column, direction) {
            premarketState.data.sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                // Handle numeric vs string comparison
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return direction === 'asc' ? valA - valB : valB - valA;
                } else {
                    valA = String(valA).toLowerCase();
                    valB = String(valB).toLowerCase();
                    if (direction === 'asc') {
                        return valA < valB ? -1 : valA > valB ? 1 : 0;
                    } else {
                        return valA > valB ? -1 : valA < valB ? 1 : 0;
                    }
                }
            });
        }

        function renderPremarketTable() {
            const tbody = document.getElementById('premarketTableBody');
            const headers = document.querySelectorAll('.premarket-table th');

            // Update sort indicators
            headers.forEach(th => {
                const column = th.getAttribute('onclick')?.match(/sortPremarketTable\('(.+?)'\)/)?.[1];
                const indicator = th.querySelector('.sort-indicator');

                if (column === premarketState.sortColumn) {
                    th.className = premarketState.sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc';
                    indicator.textContent = premarketState.sortDirection === 'asc' ? '‚ñ≤' : '‚ñº';
                } else {
                    th.className = '';
                    indicator.textContent = '';
                }
            });

            // Render rows
            tbody.innerHTML = premarketState.data.map(row => {
                const gainClass = row.gain_percent >= 0 ? 'gain-positive' : 'gain-negative';
                return `
                    <tr>
                        <td class="symbol-cell" onclick="loadSymbolFromPremarket('${row.symbol}')">${row.symbol}</td>
                        <td>$${row.prev_close.toFixed(2)}</td>
                        <td>$${row.current_price.toFixed(2)}</td>
                        <td class="${gainClass}">${row.gain_percent >= 0 ? '+' : ''}${row.gain_percent.toFixed(2)}%</td>
                        <td>${formatVolume(row.pm_volume)}</td>
                        <td>${row.pm_range > 0 ? '$' + row.pm_range.toFixed(2) : 'N/A'}</td>
                    </tr>
                `;
            }).join('');
        }

        function formatVolume(vol) {
            if (vol >= 1000000) {
                return (vol / 1000000).toFixed(2) + 'M';
            } else if (vol >= 1000) {
                return (vol / 1000).toFixed(2) + 'K';
            }
            return vol.toString();
        }

        function loadSymbolFromPremarket(symbol) {
            closePremarketPopup();

            // Set search input and load chart
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.value = symbol.toUpperCase();
            }

            handleSearch();
        }

        // ========================================
        // WATCH LIST FUNCTIONALITY
        // ========================================

        // Watch list state
        const watchListState = {
            symbols: [],
            manualSymbols: new Set(),  // Track manually added symbols
            deletedSymbols: new Set(), // Track deleted symbols (to hide on auto-refresh)
            refreshInterval: null,
            sortColumn: 'symbol',
            sortDirection: 'asc'
        };

        // Initialize watch list on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadWatchList();
            // Refresh watch list every 2 minutes (for testing)
            watchListState.refreshInterval = setInterval(loadWatchList, 120000);
        });

        // Load symbols from data/ directory CSV files
        async function loadDataDirSymbols() {
            try {
                // Get today's date in YYYYMMDD format (ET timezone)
                const today = new Date().toLocaleDateString('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                }).split('/');
                const dateStr = `${today[2]}${today[0]}${today[1]}`; // YYYYMMDD format

                const csvPath = `data/${dateStr}.csv`;
                console.log('Loading data directory CSV from:', csvPath);

                const response = await fetch(csvPath);
                if (!response.ok) {
                    console.log(`No data directory CSV found for today (${csvPath})`);
                    return [];
                }

                const csvText = await response.text();
                const lines = csvText.trim().split('\n');

                if (lines.length <= 1) {
                    console.log('Data directory CSV is empty');
                    return [];
                }

                // Parse CSV - expecting format: Symbol,Signal,Long Delta,Resistance,Max,Last,%Chg,Volume,Float,Mkt.Cap.
                // CSV column indices
                const SYMBOL_COL = 0;
                const GAIN_PERCENT_COL = 5;

                const symbols = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = line.split(',');
                    if (values.length > 0) {
                        const symbol = values[SYMBOL_COL].trim();
                        if (symbol) {
                            // Extract %Chg if available
                            let gainPercent = null;
                            if (values.length > GAIN_PERCENT_COL && values[GAIN_PERCENT_COL]) {
                                const chgStr = values[GAIN_PERCENT_COL].trim().replace('%', '');
                                const parsed = parseFloat(chgStr);
                                if (!isNaN(parsed)) {
                                    gainPercent = parsed;
                                }
                            }

                            symbols.push({
                                symbol: symbol,
                                manual: false,
                                news: false,
                                top_gainers: true, // Mark as coming from data directory
                                alpaca_top_gainers: false,
                                surge: false,
                                gain_percent: gainPercent,
                                surge_amount: null,
                                source: 'data_dir'
                            });
                        }
                    }
                }

                console.log(`Loaded ${symbols.length} symbols from data directory CSV`);
                return symbols;
            } catch (error) {
                console.error('Error loading data directory symbols:', error);
                return [];
            }
        }

        // Load watch list from API
        async function loadWatchList() {
            // Auto-subscribe thresholds
            const AUTO_SUBSCRIBE_GAIN_THRESHOLD = 30;  // Gain percent threshold (30%)
            const AUTO_SUBSCRIBE_SURGE_THRESHOLD = 5;  // Surge multiplier threshold (5x)

            try {
                console.log('Loading watch list from API...');
                const response = await fetch('cgi-bin/api/watch_list_api.py');
                console.log('Watch list API response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Watch list data received:', data);

                if (data.success) {
                    // Filter out deleted symbols (unless they were manually re-added)
                    watchListState.symbols = data.data.filter(symbol => {
                        // Keep if NOT deleted, OR if deleted but manually re-added
                        return !watchListState.deletedSymbols.has(symbol.symbol) ||
                               watchListState.manualSymbols.has(symbol.symbol);
                    }).map(symbol => {
                        // Preserve manual flag for symbols that were manually added
                        if (watchListState.manualSymbols.has(symbol.symbol)) {
                            return { ...symbol, manual: true };
                        }
                        return symbol;
                    });

                    // Also add back any manual symbols that aren't in the API response
                    const apiSymbols = new Set(data.data.map(s => s.symbol));
                    watchListState.manualSymbols.forEach(manualSymbol => {
                        if (!apiSymbols.has(manualSymbol) && !watchListState.symbols.find(s => s.symbol === manualSymbol)) {
                            // Add manual symbol if it's not already in the list
                            watchListState.symbols.push({
                                symbol: manualSymbol,
                                manual: true,
                                news: false,
                                top_gainers: false,
                                alpaca_top_gainers: false,
                                surge: false,
                                gain_percent: null,
                                surge_amount: null
                            });
                        }
                    });

                    // Load and merge symbols from data directory
                    const dataDirSymbols = await loadDataDirSymbols();
                    const existingSymbols = new Set(watchListState.symbols.map(s => s.symbol));

                    dataDirSymbols.forEach(symbol => {
                        if (!existingSymbols.has(symbol.symbol) && !watchListState.deletedSymbols.has(symbol.symbol)) {
                            watchListState.symbols.push(symbol);
                        }
                    });

                    // Apply current sort
                    sortWatchListData(watchListState.sortColumn, watchListState.sortDirection);

                    // Auto-subscribe to symbols meeting gain and surge thresholds
                    watchListState.symbols.forEach(symbol => {
                        if (symbol.gain_percent != null && symbol.gain_percent > AUTO_SUBSCRIBE_GAIN_THRESHOLD &&
                            symbol.surge_amount != null && symbol.surge_amount >= AUTO_SUBSCRIBE_SURGE_THRESHOLD) {
                            console.log(`Auto-subscribing to ${symbol.symbol} (Gain: ${symbol.gain_percent.toFixed(2)}%, Surge: ${symbol.surge_amount.toFixed(1)}x)`);
                            subscribeToSymbol(symbol.symbol);
                        }
                    });

                    console.log(`Loaded ${watchListState.symbols.length} symbols from watch list (${data.count} from API, ${dataDirSymbols.length} from data dir, ${watchListState.deletedSymbols.size} deleted, ${watchListState.manualSymbols.size} manual)`);
                    renderWatchList();
                } else {
                    console.error('Failed to load watch list:', data.error);
                    showWatchListError(`Failed to load watch list: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error loading watch list:', error);
                showWatchListError(`Error loading watch list: ${error.message}`);
            }
        }

        // Render watch list table
        function renderWatchList() {
            const tbody = document.getElementById('watchListBody');

            if (!watchListState.symbols || watchListState.symbols.length === 0) {
                tbody.innerHTML = `
                    <tr class="watch-list-empty">
                        <td colspan="9">No symbols in watch list</td>
                    </tr>
                `;
                return;
            }

            // Update sort indicators
            const headers = document.querySelectorAll('.watch-list-table th');
            headers.forEach(th => {
                const column = th.getAttribute('onclick')?.match(/sortWatchList\('(.+?)'\)/)?.[1];
                const indicator = th.querySelector('.sort-indicator');

                if (indicator) {
                    if (column === watchListState.sortColumn) {
                        th.className = th.className.replace(/sorted-(asc|desc)/, '');
                        th.classList.add(watchListState.sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                        indicator.textContent = watchListState.sortDirection === 'asc' ? '‚ñ≤' : '‚ñº';
                    } else {
                        th.className = th.className.replace(/sorted-(asc|desc)/, '');
                        indicator.textContent = '';
                    }
                }
            });

            tbody.innerHTML = watchListState.symbols.map(symbol => {
                // Format surge amount
                const surgeStr = (symbol.surge_amount != null && symbol.surge_amount > 0)
                    ? `${symbol.surge_amount.toFixed(1)}x`
                    : '-';

                // Format gain with + sign for positive values
                const gainStr = (symbol.gain_percent != null)
                    ? (symbol.gain_percent >= 0 ? `+${symbol.gain_percent.toFixed(2)}%` : `${symbol.gain_percent.toFixed(2)}%`)
                    : '-';
                const gainClass = (symbol.gain_percent != null && symbol.gain_percent >= 0) ? 'positive' : 'negative';

                return `
                    <tr ondblclick="openChartFromWatchList('${symbol.symbol}')">
                        <td class="symbol-cell">${symbol.symbol}</td>
                        <td class="source-cell">
                            <span class="source-indicator ${symbol.manual ? 'on' : 'off'}"
                                  title="${symbol.manual ? 'Manual: Yes' : 'Manual: No'}"></span>
                        </td>
                        <td class="source-cell" onclick="event.stopPropagation(); toggleNewsIndicator('${symbol.symbol}')" style="cursor: pointer;">
                            <span class="source-indicator ${symbol.news ? 'on' : 'off'}"
                                  title="${symbol.news ? 'News: Yes' : 'News: No'}"></span>
                        </td>
                        <td class="source-cell">
                            <span class="source-indicator ${symbol.top_gainers ? 'on' : 'off'}"
                                  title="${symbol.top_gainers ? 'Premarket Top Gainers: Yes' : 'Premarket Top Gainers: No'}"></span>
                        </td>
                        <td class="source-cell">
                            <span class="source-indicator ${symbol.alpaca_top_gainers ? 'on' : 'off'}"
                                  title="${symbol.alpaca_top_gainers ? 'Alpaca Top Gainers: Yes' : 'Alpaca Top Gainers: No'}"></span>
                        </td>
                        <td class="surge-cell">${surgeStr}</td>
                        <td class="gain-cell ${gainClass}">${gainStr}</td>
                        <td class="del-cell">
                            <button class="delete-btn"
                                    onclick="event.stopPropagation(); deleteSymbolFromWatchList('${symbol.symbol}')"
                                    title="Delete ${symbol.symbol}">
                                üóëÔ∏è
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // Show watch list error
        function showWatchListError(message) {
            const tbody = document.getElementById('watchListBody');
            tbody.innerHTML = `
                <tr class="watch-list-empty">
                    <td colspan="9" style="color: var(--accent-red);">${message}</td>
                </tr>
            `;
        }

        // Sort watch list table
        function sortWatchList(column) {
            if (watchListState.sortColumn === column) {
                // Toggle direction
                watchListState.sortDirection = watchListState.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // New column, default to descending for numeric columns, ascending for text
                watchListState.sortColumn = column;
                watchListState.sortDirection = column === 'symbol' ? 'asc' : 'desc';
            }

            sortWatchListData(column, watchListState.sortDirection);
            renderWatchList();
        }

        // Sort watch list data
        function sortWatchListData(column, direction) {
            const booleanColumns = ['manual', 'news', 'top_gainers', 'alpaca_top_gainers'];

            watchListState.symbols.sort((a, b) => {
                // Special handling for boolean source columns
                if (booleanColumns.includes(column)) {
                    const valA = a[column];
                    const valB = b[column];

                    // Sort by boolean value first
                    if (valA === valB) {
                        // Special case: for top_gainers, sort by gain_percent as secondary sort
                        if (column === 'top_gainers') {
                            const gainA = a.gain_percent ?? -Infinity;
                            const gainB = b.gain_percent ?? -Infinity;
                            return gainB - gainA;  // Descending order (higher gains first)
                        }

                        // For other boolean columns, sort by symbol alphabetically
                        return a.symbol.toLowerCase() < b.symbol.toLowerCase() ? -1 :
                               a.symbol.toLowerCase() > b.symbol.toLowerCase() ? 1 : 0;
                    }

                    // Different boolean values - true comes first for desc, last for asc
                    if (direction === 'desc') {
                        return valA ? -1 : 1;  // true (-1) comes before false (1)
                    } else {
                        return valA ? 1 : -1;  // false (-1) comes before true (1)
                    }
                }

                // Original sorting logic for other columns
                let valA = a[column];
                let valB = b[column];

                // Handle null/undefined values - push them to the end
                if (valA == null && valB == null) return 0;
                if (valA == null) return 1;
                if (valB == null) return -1;

                // Handle numeric vs string comparison
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return direction === 'asc' ? valA - valB : valB - valA;
                } else {
                    valA = String(valA).toLowerCase();
                    valB = String(valB).toLowerCase();
                    if (direction === 'asc') {
                        return valA < valB ? -1 : valA > valB ? 1 : 0;
                    } else {
                        return valA > valB ? -1 : valA < valB ? 1 : 0;
                    }
                }
            });
        }

        // Open chart from watch list (double-click)
        function openChartFromWatchList(symbol) {
            if (!symbol) return;

            console.log(`Opening chart for ${symbol} from watch list`);

            // Set search input value
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.value = symbol.toUpperCase();
            }

            // Open chart
            handleSearch();
        }

        // Handle keypress in watch list add input
        function handleWatchListKeypress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                addSymbolToWatchList();
            }
        }

        // Add symbol to watch list
        async function addSymbolToWatchList() {
            const input = document.getElementById('watchListAddInput');
            if (!input) return;

            const symbol = input.value.trim().toUpperCase();

            if (!symbol) {
                return;
            }

            // Check if symbol already exists
            const existingSymbol = watchListState.symbols.find(s => s.symbol === symbol);
            if (existingSymbol) {
                // Mark existing symbol as manually added
                existingSymbol.manual = true;
                watchListState.manualSymbols.add(symbol);

                // Re-render to show the manual indicator
                renderWatchList();
                input.value = '';

                console.log(`Symbol ${symbol} already in watch list, marked as manual`);

                // Send to backend API to be monitored by momentum_alerts.py
                try {
                    const response = await fetch('cgi-bin/api/manual_symbols_api.py', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ symbol: symbol })
                    });

                    const result = await response.json();

                    if (result.success) {
                        console.log(`‚úÖ Symbol ${symbol} sent to momentum_alerts.py for monitoring`);
                    } else {
                        console.error(`‚ùå Failed to send ${symbol} to backend:`, result.error);
                    }
                } catch (error) {
                    console.error(`‚ùå Error sending ${symbol} to backend:`, error);
                }

                return;
            }

            // If this symbol was previously deleted, remove it from deleted set
            // This allows it to show up again even after auto-refresh
            if (watchListState.deletedSymbols.has(symbol)) {
                watchListState.deletedSymbols.delete(symbol);
                console.log(`Symbol ${symbol} was previously deleted, now re-adding as manual`);
            }

            // Add symbol to list
            const newSymbol = {
                symbol: symbol,
                manual: true,
                news: false,
                top_gainers: false,
                alpaca_top_gainers: false,
                surge: false,
                gain_percent: null,
                surge_amount: null
            };

            watchListState.symbols.push(newSymbol);
            watchListState.manualSymbols.add(symbol);

            // Re-sort symbols
            sortWatchListData(watchListState.sortColumn, watchListState.sortDirection);

            // Render and clear input
            renderWatchList();
            input.value = '';

            console.log(`Added ${symbol} to watch list (manual symbols: ${watchListState.manualSymbols.size})`);

            // Send to backend API to be monitored by momentum_alerts.py
            try {
                const response = await fetch('cgi-bin/api/manual_symbols_api.py', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`‚úÖ Symbol ${symbol} sent to momentum_alerts.py for monitoring`);
                } else {
                    console.error(`‚ùå Failed to send ${symbol} to backend:`, result.error);
                }
            } catch (error) {
                console.error(`‚ùå Error sending ${symbol} to backend:`, error);
            }
        }

        // Toggle news indicator for a symbol
        function toggleNewsIndicator(symbol) {
            if (!symbol) return;

            console.log(`Toggling news indicator for ${symbol}`);

            // Find the symbol in the watch list
            const symbolObj = watchListState.symbols.find(s => s.symbol === symbol);
            if (symbolObj) {
                // Toggle the news property
                symbolObj.news = !symbolObj.news;
                console.log(`News indicator for ${symbol} is now ${symbolObj.news ? 'on' : 'off'}`);

                // Re-render the watch list to update the display
                renderWatchList();

                // Save to backend if it's a manual symbol
                if (watchListState.manualSymbols.has(symbol)) {
                    saveManualSymbolsToBackend();
                }
            }
        }

        // Delete symbol from watch list
        async function deleteSymbolFromWatchList(symbol) {
            if (!symbol) return;

            console.log(`Deleting ${symbol} from watch list`);

            // Check if this is a manually added symbol
            const isManual = watchListState.manualSymbols.has(symbol);

            // Remove from symbols array
            watchListState.symbols = watchListState.symbols.filter(s => s.symbol !== symbol);

            if (isManual) {
                // If it was manually added, remove from manual set
                watchListState.manualSymbols.delete(symbol);
                console.log(`Removed ${symbol} from manual symbols`);

                // Send DELETE request to backend API
                try {
                    const response = await fetch('cgi-bin/api/manual_symbols_api.py', {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ symbol: symbol })
                    });

                    const result = await response.json();

                    if (result.success) {
                        console.log(`‚úÖ Symbol ${symbol} removed from momentum_alerts.py monitoring`);
                    } else {
                        console.error(`‚ùå Failed to remove ${symbol} from backend:`, result.error);
                    }
                } catch (error) {
                    console.error(`‚ùå Error removing ${symbol} from backend:`, error);
                }
            } else {
                // If it came from API, add to deleted set to prevent it from showing up on auto-refresh
                watchListState.deletedSymbols.add(symbol);
                console.log(`Added ${symbol} to deleted symbols (will hide on auto-refresh)`);
            }

            // Re-render
            renderWatchList();

            console.log(`Deleted ${symbol} from watch list (manual: ${watchListState.manualSymbols.size}, deleted: ${watchListState.deletedSymbols.size})`);
        }

        // ========================================
        // SCANNER FUNCTIONALITY
        // ========================================

        // Scanner state
        const scannerState = {
            alerts: [],
            refreshInterval: null,
            resizing: {
                isResizing: false,
                currentColumn: null,
                startX: 0,
                startWidth: 0
            }
        };

        // Initialize scanner on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadScanner();
            // Refresh scanner every 5 seconds
            scannerState.refreshInterval = setInterval(loadScanner, 5000);
            // Initialize column resizing
            initScannerColumnResize();
        });

        // Load scanner alerts from API
        async function loadScanner() {
            try {
                console.log('Loading scanner alerts from API...');
                const response = await fetch('cgi-bin/api/scanner_api.py');
                console.log('Scanner API response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Scanner data received:', data);

                if (data.success) {
                    scannerState.alerts = data.data;
                    console.log(`Loaded ${scannerState.alerts.length} momentum alerts`);
                    renderScanner();
                } else {
                    console.error('Failed to load scanner:', data.error);
                    showScannerError(`Failed to load scanner: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error loading scanner:', error);
                showScannerError(`Error loading scanner: ${error.message}`);
            }
        }

        // Render scanner table
        function renderScanner() {
            const tbody = document.getElementById('scannerBody');

            if (!scannerState.alerts || scannerState.alerts.length === 0) {
                tbody.innerHTML = `
                    <tr class="scanner-empty">
                        <td colspan="7">No alerts</td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = scannerState.alerts.map(alert => {
                // Format gain with + sign for positive values
                const gainStr = (alert.gain != null)
                    ? (alert.gain >= 0 ? `+${alert.gain.toFixed(2)}%` : `${alert.gain.toFixed(2)}%`)
                    : 'N/A';
                const gainClass = (alert.gain != null && alert.gain >= 0) ? 'positive' : 'negative';

                // Format price with 2 decimal places
                const priceStr = alert.price ? `$${alert.price.toFixed(2)}` : 'N/A';

                // Style source based on alert type
                const sourceClass = alert.source === 'Squeeze' ? 'squeeze-source' : '';
                const sourceDisplay = alert.source === 'Squeeze' ? 'üöÄ Squeeze' : 'üìà Momentum';

                // Determine background color based on HOD and premarket high indicators
                let bgColor = '';
                if (alert.regular_hours_hod_status && alert.regular_hours_hod_status.color === 'green') {
                    bgColor = 'background-color: green;';
                } else if (alert.premarket_high_status && alert.premarket_high_status.color === 'green') {
                    bgColor = 'background-color: lime;';
                }

                return `
                    <tr ondblclick="openChartFromScanner('${alert.symbol}')" style="${bgColor}">
                        <td class="symbol-cell">${alert.symbol}</td>
                        <td class="source-cell ${sourceClass}">${sourceDisplay}</td>
                        <td class="time-cell">${alert.time}</td>
                        <td class="price-cell">${priceStr}</td>
                        <td class="gain-cell ${gainClass}">${gainStr}</td>
                        <td class="text-cell">${alert.text}</td>
                    </tr>
                `;
            }).join('');
        }

        // Show scanner error
        function showScannerError(message) {
            const tbody = document.getElementById('scannerBody');
            tbody.innerHTML = `
                <tr class="scanner-empty">
                    <td colspan="6" style="color: var(--accent-red);">${message}</td>
                </tr>
            `;
        }

        // ==================== Fundamentals Functions ====================

        // Open chart from scanner (double-click)
        function openChartFromScanner(symbol) {
            if (!symbol) return;

            console.log(`Opening chart for ${symbol} from scanner`);

            // Set search input value
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.value = symbol.toUpperCase();
            }

            // Open chart
            handleSearch();
        }

        // Initialize scanner column resizing
        function initScannerColumnResize() {
            const table = document.querySelector('.scanner-table');
            if (!table) return;

            const headers = table.querySelectorAll('th');

            headers.forEach((header, index) => {
                const resizeHandle = header.querySelector('.resize-handle');
                if (!resizeHandle) return;

                resizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    scannerState.resizing.isResizing = true;
                    scannerState.resizing.currentColumn = header;
                    scannerState.resizing.startX = e.pageX;
                    scannerState.resizing.startWidth = header.offsetWidth;

                    header.classList.add('resizing');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                });
            });

            // Global mouse move handler
            document.addEventListener('mousemove', (e) => {
                if (!scannerState.resizing.isResizing) return;

                const diff = e.pageX - scannerState.resizing.startX;
                const newWidth = scannerState.resizing.startWidth + diff;

                // Set minimum width of 50px
                if (newWidth >= 50) {
                    scannerState.resizing.currentColumn.style.width = newWidth + 'px';
                    scannerState.resizing.currentColumn.style.minWidth = newWidth + 'px';
                }
            });

            // Global mouse up handler
            document.addEventListener('mouseup', () => {
                if (scannerState.resizing.isResizing) {
                    scannerState.resizing.isResizing = false;
                    if (scannerState.resizing.currentColumn) {
                        scannerState.resizing.currentColumn.classList.remove('resizing');
                    }
                    scannerState.resizing.currentColumn = null;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

    </script>
</body>
</html>
