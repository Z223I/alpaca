<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Sentinel - Real-time Stock Monitor</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">

    <!-- TradingView Lightweight Charts for professional candlestick charts -->
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --text-primary: #e4e4e4;
            --text-secondary: #a0a0a0;
            --accent-green: #4ecca3;
            --accent-red: #ff6b6b;
            --accent-blue: #4dabf7;
            --border-color: #2a2a3e;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Header */
        .header {
            background-color: var(--bg-secondary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--accent-green);
        }

        /* Search Bar */
        .search-container {
            display: flex;
            align-items: center;
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            padding: 8px 15px;
            flex: 0 0 400px;
        }

        .search-container input {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 16px;
            outline: none;
            flex: 1;
            padding: 5px;
            text-transform: uppercase;
        }

        .search-container input::placeholder {
            color: var(--text-secondary);
        }

        .search-icon {
            cursor: pointer;
            color: var(--accent-blue);
            font-size: 20px;
            margin-left: 10px;
        }

        .search-icon:hover {
            color: var(--accent-green);
        }

        /* Main Container */
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
        }

        /* Tab Bar */
        .tab-bar {
            background-color: var(--bg-secondary);
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 5px;
            overflow-x: auto;
            min-height: 50px;
        }

        .tab {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 5px 5px 0 0;
            padding: 10px 20px;
            cursor: pointer;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background-color 0.2s;
        }

        .tab:hover {
            background-color: var(--bg-primary);
        }

        .tab.active {
            background-color: var(--bg-primary);
            border-bottom: 2px solid var(--accent-green);
        }

        .tab-close {
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
        }

        .tab-close:hover {
            color: var(--accent-red);
        }

        /* Chart Container */
        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-primary);
            overflow: hidden;
        }

        .chart-panel {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
        }

        .chart-panel.active {
            display: flex;
        }

        /* Chart Controls */
        .chart-controls {
            background-color: var(--bg-secondary);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .control-group label {
            color: var(--text-secondary);
            font-size: 14px;
            margin-right: 5px;
        }

        .control-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background-color: var(--accent-blue);
            color: white;
        }

        .control-btn.active {
            background-color: var(--accent-green);
            color: white;
            border-color: var(--accent-green);
        }

        .control-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        .control-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .indicator-note {
            font-size: 0.75em;
            color: var(--text-secondary);
            opacity: 0.7;
            font-style: italic;
        }

        .save-settings-btn {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            margin-left: 10px;
        }

        .save-settings-btn:hover {
            background-color: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }

        .save-settings-btn.saved {
            background-color: var(--accent-green);
            border-color: var(--accent-green);
            color: white;
        }

        /* Chart Display Area */
        .chart-display {
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
            display: flex;
            overflow: auto;  /* Enable scrolling to debug */
        }

        .chart-main {
            flex: 1;
            min-height: 0;  /* Critical: prevents flex item from expanding beyond parent */
            padding: 20px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .canvas-container {
            flex: 1;
            min-height: 0;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
        }

        .main-chart {
            flex: 3;
            width: 100%;
            min-height: 500px;
            background-color: #16213e;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
        }

        /* Chart Legend */
        .chart-legend {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(26, 26, 46, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 10px 15px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.6;
            pointer-events: none;
        }

        .legend-symbol {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent-blue);
            margin-bottom: 5px;
        }

        .legend-price {
            font-size: 16px;
            font-weight: 600;
        }

        .legend-price.up {
            color: var(--accent-green);
        }

        .legend-price.down {
            color: var(--accent-red);
        }

        .legend-change {
            font-size: 13px;
            margin-left: 8px;
        }

        .legend-details {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 3px;
        }

        .legend-indicators {
            font-size: 11px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-indicator-item {
            margin: 2px 0;
            display: flex;
            align-items: center;
        }

        .legend-indicator-color {
            width: 12px;
            height: 2px;
            margin-right: 6px;
            display: inline-block;
        }

        .legend-indicator-label {
            color: var(--text-secondary);
            margin-right: 4px;
        }

        .legend-indicator-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .legend-volume {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 3px;
        }

        .legend-volume-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .volume-chart {
            flex: 1;
            width: 100%;
            min-height: 120px;
            background-color: #0f3460;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            position: relative;
        }

        /* Chart Resize Handle (between main chart and volume chart) */
        .chart-resize-handle {
            width: 100%;
            height: 8px;
            cursor: row-resize;
            background-color: transparent;
            position: relative;
            z-index: 100;
            transition: background-color 0.2s;
            margin: 5px 0;
        }

        .chart-resize-handle:hover {
            background-color: var(--accent-blue);
        }

        .chart-resize-handle.resizing {
            background-color: var(--accent-green);
        }

        /* Time and Sales Panel */
        .time-sales-panel {
            width: 300px;
            min-width: 200px;
            max-width: 600px;
            background-color: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Time & Sales Resize Handle */
        .time-sales-resize {
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            background-color: transparent;
            z-index: 10;
            transition: background-color 0.2s;
            pointer-events: auto;
        }

        .time-sales-resize:hover {
            background-color: var(--accent-blue);
        }

        .time-sales-panel.resizing {
            user-select: none;
        }

        .time-sales-panel.resizing .time-sales-resize {
            background-color: var(--accent-green);
        }

        .time-sales-header {
            background-color: var(--bg-tertiary);
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .time-sales-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .trade-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .trade-item:hover {
            background-color: var(--bg-tertiary);
        }

        .trade-time {
            color: var(--text-secondary);
            font-size: 11px;
        }

        .trade-price {
            font-weight: 600;
        }

        .trade-price.up {
            color: var(--accent-green);
        }

        .trade-price.down {
            color: var(--accent-red);
        }

        .trade-size {
            color: var(--text-secondary);
            font-size: 12px;
        }

        /* Resize Handle */
        .resize-handle {
            width: 5px;
            background-color: var(--border-color);
            cursor: col-resize;
            position: relative;
        }

        .resize-handle:hover {
            background-color: var(--accent-blue);
        }

        /* Status Bar */
        .status-bar {
            background-color: var(--bg-secondary);
            padding: 8px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--accent-green);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }

        /* Loading Spinner */
        .loading {
            display: none;
            text-align: center;
            padding: 50px;
            color: var(--text-secondary);
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-blue);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Left Sidebar Container */
        .left-sidebar {
            width: 700px;
            min-width: 500px;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            border-right: 2px solid var(--border-color);
            overflow: hidden;
            padding-bottom: 30px; /* Add space at bottom */
            position: relative; /* For resize handle positioning */
        }

        /* Left Sidebar Resize Handle */
        .left-sidebar-resize {
            position: absolute;
            top: 0;
            right: 12px;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            background-color: transparent;
            z-index: 10;
            transition: background-color 0.2s;
        }

        .left-sidebar-resize:hover {
            background-color: var(--accent-blue);
        }

        .left-sidebar.resizing {
            user-select: none;
        }

        .left-sidebar.resizing .left-sidebar-resize {
            background-color: var(--accent-green);
        }

        /* Watch List Panel */
        .watch-list-panel {
            flex: 1;
            background-color: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .watch-list-header {
            background-color: var(--bg-tertiary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .watch-list-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-green);
            margin: 0;
        }

        .watch-list-add-container {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
        }

        .watch-list-add-input {
            flex: 1;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            text-transform: uppercase;
        }

        .watch-list-add-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .watch-list-add-btn {
            background-color: var(--accent-green);
            border: none;
            color: var(--bg-primary);
            padding: 8px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .watch-list-add-btn:hover {
            background-color: #3dba8a;
        }

        .watch-list-table-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
        }

        .watch-list-table {
            width: 100%;
            border-collapse: collapse;
        }

        .watch-list-table thead {
            position: sticky;
            top: 0;
            background-color: var(--bg-tertiary);
            z-index: 10;
        }

        .watch-list-table th {
            padding: 12px 10px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-color);
            white-space: nowrap;
        }

        .watch-list-table th.source-col {
            text-align: center;
            width: 60px;
        }

        .watch-list-table th.del-col {
            text-align: center;
            width: 50px;
        }

        .watch-list-table tbody tr {
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .watch-list-table tbody tr:hover {
            background-color: var(--bg-tertiary);
        }

        .watch-list-table td {
            padding: 10px;
            font-size: 14px;
        }

        .watch-list-table td.symbol-cell {
            font-weight: 600;
            color: var(--accent-blue);
        }

        .watch-list-table td.source-cell {
            text-align: center;
            font-size: 16px;
        }

        .watch-list-table td.del-cell {
            text-align: center;
        }

        .source-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin: 0 2px;
        }

        .source-indicator.on {
            background-color: var(--accent-green);
        }

        .source-indicator.off {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
        }

        .delete-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s;
        }

        .delete-btn:hover {
            color: var(--accent-red);
        }

        .watch-list-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Scanner Panel */
        .scanner-panel {
            flex: 1;
            background-color: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* Scanner Subpanel */
        .scanner-subpanel {
            background-color: var(--bg-tertiary);
            border-top: 2px solid var(--border-color);
            height: 60px;
            flex-shrink: 0;
            margin-bottom: 20px; /* Add space at bottom so content doesn't go off screen */
        }

        .scanner-header {
            background-color: var(--bg-tertiary);
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .scanner-header h2 {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-green);
            margin: 0;
        }

        .scanner-table-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            padding-bottom: 60px; /* Add space at bottom so last rows are visible */
        }

        .scanner-table {
            width: 100%;
            border-collapse: collapse;
        }

        .scanner-table thead {
            position: sticky;
            top: 0;
            background-color: var(--bg-tertiary);
            z-index: 10;
        }

        .scanner-table th {
            padding: 12px 10px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-color);
            white-space: nowrap;
            position: relative;
            user-select: none;
        }

        /* Column resize handle */
        .scanner-table th .resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 5px;
            height: 100%;
            cursor: col-resize;
            background-color: transparent;
            z-index: 1;
        }

        .scanner-table th .resize-handle:hover {
            background-color: var(--accent-blue);
        }

        .scanner-table th.resizing {
            border-right: 2px solid var(--accent-blue);
        }

        .scanner-table th.source-col {
            text-align: center;
            width: 80px;
        }

        .scanner-table th.time-col {
            width: 80px;
        }

        .scanner-table th.gain-col {
            text-align: right;
            width: 70px;
        }

        .scanner-table th.volume-col {
            text-align: right;
            width: 90px;
        }

        .scanner-table tbody tr {
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .scanner-table tbody tr:hover {
            background-color: var(--bg-tertiary);
        }

        .scanner-table td {
            padding: 10px;
            font-size: 14px;
        }

        .scanner-table td.symbol-cell {
            font-weight: 600;
            color: var(--accent-blue);
        }

        .scanner-table td.source-cell {
            text-align: center;
            font-weight: 600;
            color: var(--accent-green);
        }

        .scanner-table td.time-cell {
            color: var(--text-secondary);
            font-size: 12px;
        }

        .scanner-table td.gain-cell {
            text-align: right;
            font-weight: 600;
        }

        .scanner-table td.gain-cell.positive {
            color: var(--accent-green);
        }

        .scanner-table td.gain-cell.negative {
            color: var(--accent-red);
        }

        .scanner-table td.volume-cell {
            text-align: right;
            color: var(--text-primary);
            font-size: 13px;
        }

        .scanner-table td.text-cell {
            font-size: 11px;
            color: var(--text-secondary);
            max-width: 200px;
        }

        .scanner-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Welcome Message */
        .welcome-message {
            text-align: center;
            padding: 100px 50px;
            color: var(--text-secondary);
        }

        .welcome-message h2 {
            font-size: 36px;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .welcome-message p {
            font-size: 18px;
            line-height: 1.6;
        }

    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>üìä Market Sentinel</h1>
        <div class="search-container">
            <input
                type="text"
                id="symbolSearch"
                placeholder="Enter stock symbol (e.g., AAPL, GOOGL, TSLA)"
                onkeypress="handleSearchKeypress(event)"
            />
            <span class="search-icon" onclick="handleSearch()">üîç</span>
        </div>
    </div>

    <!-- Tab Bar -->
    <div class="tab-bar" id="tabBar">
        <!-- Tabs will be added dynamically -->
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Sidebar: Watch List + Scanner -->
        <div class="left-sidebar">
            <!-- Watch List Panel -->
            <div class="watch-list-panel">
            <div class="watch-list-header">
                <h2>üìã Watch List</h2>
            </div>

            <!-- Add Symbol Section -->
            <div class="watch-list-add-container">
                <input
                    type="text"
                    id="watchListAddInput"
                    class="watch-list-add-input"
                    placeholder="Add symbol..."
                    onkeypress="handleWatchListKeypress(event)"
                />
                <button class="watch-list-add-btn" onclick="addSymbolToWatchList()">Add</button>
            </div>

            <!-- Symbol Table -->
            <div class="watch-list-table-container">
                <table class="watch-list-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th class="source-col" title="Oracle">üîÆ</th>
                            <th class="source-col" title="Manual">‚úèÔ∏è</th>
                            <th class="source-col" title="Top Gainers">üìà</th>
                            <th class="source-col" title="Volume Surge">üöÄ</th>
                            <th class="del-col">Del</th>
                        </tr>
                    </thead>
                    <tbody id="watchListBody">
                        <!-- Symbols will be populated here -->
                        <tr class="watch-list-empty">
                            <td colspan="6">Loading watch list...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Scanner Panel -->
        <div class="scanner-panel">
            <div class="scanner-header">
                <h2>üîç Scanner</h2>
            </div>

            <!-- Scanner Table -->
            <div class="scanner-table-container">
                <table class="scanner-table">
                    <thead>
                        <tr>
                            <th>Symbol<div class="resize-handle"></div></th>
                            <th class="source-col">Source<div class="resize-handle"></div></th>
                            <th class="time-col">Time<div class="resize-handle"></div></th>
                            <th class="gain-col">Gain<div class="resize-handle"></div></th>
                            <th class="volume-col">Volume<div class="resize-handle"></div></th>
                            <th>Text<div class="resize-handle"></div></th>
                        </tr>
                    </thead>
                    <tbody id="scannerBody">
                        <!-- Alerts will be populated here -->
                        <tr class="scanner-empty">
                            <td colspan="6">Loading scanner...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Scanner Subpanel -->
        <div class="scanner-subpanel">
        </div>

        <!-- Left Sidebar Resize Handle -->
        <div class="left-sidebar-resize" id="leftSidebarResize"></div>
        </div><!-- End of left-sidebar -->

        <div class="chart-container" id="chartContainer">
            <!-- Welcome Message (shown when no charts open) -->
            <div class="welcome-message" id="welcomeMessage">
                <h2>Welcome to Market Sentinel</h2>
                <p>Enter a stock symbol in the search bar above to begin monitoring real-time market data.</p>
                <p>Features include candlestick charts, EMAs, VWAP, MACD, volume analysis, and time & sales data.</p>
            </div>

            <!-- Chart panels will be added dynamically -->
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-indicator">
            <span class="status-dot"></span>
            <span id="statusText">Ready</span>
        </div>
        <div>
            <span id="updateTime">Last updated: Never</span>
        </div>
    </div>

    <script>
        console.log('‚úÖ SCRIPT START - Beginning of main script block');

        // Global state
        const state = {
            charts: new Map(),
            activeChart: null,
            updateIntervals: new Map(),
            timeSalesIntervals: new Map(),
            tradeWebSocket: null,
            tradeBuffer: new Map(),  // Buffer for real-time trades
            wsReconnectAttempts: 0,
            wsMaxReconnectAttempts: 5,
            leftSidebarResize: {
                isResizing: false,
                startX: 0,
                startWidth: 0
            },
            timeSalesResize: {
                isResizing: false,
                currentPanel: null,
                chartMain: null,
                startX: 0,
                startWidth: 0,
                startChartWidth: 0
            },
            chartResize: {
                isResizing: false,
                currentMainChart: null,
                currentVolumeChart: null,
                startY: 0,
                startMainHeight: 0,
                startVolumeHeight: 0
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Market Sentinel initialized');
            updateStatus('Ready', 'System initialized');
            initializeTradeWebSocket();
            initLeftSidebarResize();

            // Auto-focus search bar on page load
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.focus();
            }
        });

        // Global keyboard handler - any keystroke focuses search bar
        document.addEventListener('keydown', (event) => {
            const searchInput = document.getElementById('symbolSearch');
            const activeElement = document.activeElement;

            // Don't interfere if user is already typing in any input field or textarea
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                return;
            }

            // Don't interfere with special keys (Ctrl, Alt, etc.) or function keys
            if (event.ctrlKey || event.altKey || event.metaKey || event.key.startsWith('F')) {
                return;
            }

            // Don't interfere with navigation keys when not in search
            const navigationKeys = ['Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
            if (navigationKeys.includes(event.key)) {
                return;
            }

            // For any other printable character, focus the search bar
            if (event.key.length === 1 || event.key === 'Backspace') {
                searchInput.focus();
                // If it's a backspace, let it work on the search field
                // If it's a character, it will be automatically added to the focused input
            }
        });

        // Initialize WebSocket connection for real-time trades
        function initializeTradeWebSocket() {
            const wsUrl = 'ws://localhost:8765';
            console.log('Connecting to trade stream:', wsUrl);
            updateStatus('Connecting', 'Connecting to real-time trade stream...');

            try {
                state.tradeWebSocket = new WebSocket(wsUrl);

                state.tradeWebSocket.onopen = () => {
                    console.log('‚úÖ WebSocket connected to trade stream');
                    updateStatus('Connected', 'Real-time trade stream active');
                    state.wsReconnectAttempts = 0;

                    // Resubscribe to all active symbols
                    state.charts.forEach((chartData, symbol) => {
                        subscribeToSymbol(symbol);
                    });
                };

                state.tradeWebSocket.onmessage = (event) => {
                    handleTradeMessage(event.data);
                };

                state.tradeWebSocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Error', 'Trade stream connection error');
                };

                state.tradeWebSocket.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateStatus('Disconnected', 'Trade stream disconnected');
                    state.tradeWebSocket = null;

                    // Attempt reconnection
                    if (state.wsReconnectAttempts < state.wsMaxReconnectAttempts) {
                        state.wsReconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, state.wsReconnectAttempts), 30000);
                        console.log(`Reconnecting in ${delay/1000}s (attempt ${state.wsReconnectAttempts}/${state.wsMaxReconnectAttempts})...`);
                        setTimeout(initializeTradeWebSocket, delay);
                    } else {
                        console.error('Max reconnection attempts reached. Please refresh the page.');
                        updateStatus('Error', 'Trade stream unavailable. Please refresh page.');
                    }
                };

                // Keep-alive ping every 30 seconds
                setInterval(() => {
                    if (state.tradeWebSocket && state.tradeWebSocket.readyState === WebSocket.OPEN) {
                        state.tradeWebSocket.send(JSON.stringify({ action: 'ping' }));
                    }
                }, 30000);

            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                updateStatus('Error', 'Failed to connect to trade stream');
            }
        }

        // Subscribe to real-time trades for a symbol
        function subscribeToSymbol(symbol) {
            if (!state.tradeWebSocket || state.tradeWebSocket.readyState !== WebSocket.OPEN) {
                console.warn('WebSocket not ready, cannot subscribe to', symbol);
                return;
            }

            console.log('Subscribing to real-time trades for', symbol);
            state.tradeWebSocket.send(JSON.stringify({
                action: 'subscribe',
                symbol: symbol
            }));

            // Initialize trade buffer for this symbol
            if (!state.tradeBuffer.has(symbol)) {
                state.tradeBuffer.set(symbol, []);
            }
        }

        // Unsubscribe from real-time trades for a symbol
        function unsubscribeFromSymbol(symbol) {
            if (!state.tradeWebSocket || state.tradeWebSocket.readyState !== WebSocket.OPEN) {
                return;
            }

            console.log('Unsubscribing from real-time trades for', symbol);
            state.tradeWebSocket.send(JSON.stringify({
                action: 'unsubscribe',
                symbol: symbol
            }));

            // Clear trade buffer
            state.tradeBuffer.delete(symbol);
        }

        // Handle incoming WebSocket trade messages
        function handleTradeMessage(message) {
            try {
                const data = JSON.parse(message);

                if (data.type === 'trade') {
                    handleRealTimeTrade(data.symbol, data.data);
                } else if (data.type === 'subscribed') {
                    console.log('‚úÖ Subscribed to', data.symbol);
                } else if (data.type === 'unsubscribed') {
                    console.log('Unsubscribed from', data.symbol);
                } else if (data.type === 'pong') {
                    // Keep-alive response
                }
            } catch (error) {
                console.error('Error handling trade message:', error);
            }
        }

        // Handle a real-time trade update
        function handleRealTimeTrade(symbol, tradeData) {
            console.log(`Real-time trade for ${symbol}:`, tradeData);

            // Add to buffer
            const buffer = state.tradeBuffer.get(symbol) || [];
            buffer.unshift(tradeData);  // Add to front (newest first)

            // Keep only last 100 trades in buffer
            if (buffer.length > 100) {
                buffer.pop();
            }
            state.tradeBuffer.set(symbol, buffer);

            // Update display if this symbol is active
            const chartData = state.charts.get(symbol);
            if (chartData) {
                addTradeToDisplay(symbol, tradeData);
            }
        }

        // Add a single trade to the display
        function addTradeToDisplay(symbol, tradeData) {
            const container = document.getElementById(`trades-${symbol}`);
            if (!container) {
                return;
            }

            const chartData = state.charts.get(symbol);
            if (!chartData) {
                return;
            }

            // Determine price direction
            const priceClass = chartData.lastPrice && tradeData.price > chartData.lastPrice ? 'up' :
                              chartData.lastPrice && tradeData.price < chartData.lastPrice ? 'down' : '';

            // Format time in ET timezone
            const tradeTime = new Date(tradeData.timestamp).toLocaleTimeString('en-US', {
                timeZone: 'America/New_York',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });

            // Create trade item element
            const tradeItem = document.createElement('div');
            tradeItem.className = 'trade-item';
            tradeItem.innerHTML = `
                <div>
                    <div class="trade-time">${tradeTime} ET</div>
                    <div class="trade-price ${priceClass}">$${tradeData.price.toFixed(2)}</div>
                </div>
                <div class="trade-size">${tradeData.size.toLocaleString()}</div>
            `;

            // Add flash animation
            tradeItem.style.backgroundColor = 'rgba(78, 204, 163, 0.3)';
            setTimeout(() => {
                tradeItem.style.backgroundColor = '';
            }, 1000);

            // Check if user is scrolled to top (within 50px threshold)
            const isScrolledToTop = container.scrollTop < 50;

            // Insert at top
            container.insertBefore(tradeItem, container.firstChild);

            // Remove excess items (keep only 100)
            while (container.children.length > 100) {
                container.removeChild(container.lastChild);
            }

            // Auto-scroll to top to show newest trades (only if already near top)
            if (isScrolledToTop) {
                container.scrollTop = 0;
            }

            // Update last price
            chartData.lastPrice = tradeData.price;
        }

        // ========================================
        // LEFT SIDEBAR RESIZE FUNCTIONALITY
        // ========================================

        function initLeftSidebarResize() {
            const leftSidebar = document.querySelector('.left-sidebar');
            const resizeHandle = document.getElementById('leftSidebarResize');

            if (!leftSidebar || !resizeHandle) {
                console.warn('Left sidebar or resize handle not found');
                return;
            }

            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                state.leftSidebarResize.isResizing = true;
                state.leftSidebarResize.startX = e.pageX;
                state.leftSidebarResize.startWidth = leftSidebar.offsetWidth;

                leftSidebar.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', (e) => {
                if (!state.leftSidebarResize.isResizing) return;

                const diff = e.pageX - state.leftSidebarResize.startX;
                const newWidth = state.leftSidebarResize.startWidth + diff;

                // Enforce min and max width constraints
                const minWidth = 500;
                const maxWidth = 900;

                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    leftSidebar.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                if (state.leftSidebarResize.isResizing) {
                    state.leftSidebarResize.isResizing = false;
                    leftSidebar.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

        // ========================================
        // TIME & SALES RESIZE FUNCTIONALITY
        // ========================================

        function initTimeSalesResize(symbol) {
            const timeSalesPanel = document.getElementById(`time-sales-${symbol}`);
            const resizeHandle = timeSalesPanel?.querySelector('.time-sales-resize');

            if (!timeSalesPanel || !resizeHandle) {
                console.warn(`Time & Sales panel or resize handle not found for ${symbol}`);
                return;
            }

            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Find the chart-main element (sibling in the chart-display div)
                const chartDisplay = timeSalesPanel.parentElement;
                const chartMain = chartDisplay?.querySelector('.chart-main');

                state.timeSalesResize.isResizing = true;
                state.timeSalesResize.currentPanel = timeSalesPanel;
                state.timeSalesResize.chartMain = chartMain;
                state.timeSalesResize.startX = e.pageX;
                state.timeSalesResize.startWidth = timeSalesPanel.offsetWidth;
                state.timeSalesResize.startChartWidth = chartMain?.offsetWidth || 0;

                timeSalesPanel.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            // Use existing global mousemove handler
            if (!state.timeSalesResize.mouseMoveAttached) {
                document.addEventListener('mousemove', (e) => {
                    if (!state.timeSalesResize.isResizing) return;

                    // Calculate new width (subtract because we're dragging from left edge)
                    // Dragging left (decreasing pageX) should increase width
                    // Dragging right (increasing pageX) should decrease width
                    const diff = state.timeSalesResize.startX - e.pageX;
                    let newWidth = state.timeSalesResize.startWidth + diff;

                    // Enforce min and max width constraints
                    const minWidth = 200;
                    const maxWidth = 600;

                    // Clamp the width
                    newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

                    // Update Time & Sales panel width
                    state.timeSalesResize.currentPanel.style.width = newWidth + 'px';
                    state.timeSalesResize.currentPanel.style.flexShrink = '0';

                    // Update chart-main width (inverse relationship)
                    if (state.timeSalesResize.chartMain) {
                        const newChartWidth = state.timeSalesResize.startChartWidth - diff;
                        state.timeSalesResize.chartMain.style.width = newChartWidth + 'px';
                        state.timeSalesResize.chartMain.style.flex = 'none';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (state.timeSalesResize.isResizing) {
                        state.timeSalesResize.isResizing = false;
                        if (state.timeSalesResize.currentPanel) {
                            state.timeSalesResize.currentPanel.classList.remove('resizing');
                        }
                        state.timeSalesResize.currentPanel = null;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                });

                state.timeSalesResize.mouseMoveAttached = true;
            }
        }

        // ========================================
        // CHART RESIZE FUNCTIONALITY
        // ========================================

        function initChartResize(symbol) {
            const mainChart = document.getElementById(`chart-${symbol}`);
            const volumeChart = document.getElementById(`volume-${symbol}`);
            const resizeHandle = document.querySelector(`.chart-resize-handle[data-symbol="${symbol}"]`);

            if (!mainChart || !volumeChart || !resizeHandle) {
                console.warn(`Chart elements or resize handle not found for ${symbol}`);
                return;
            }

            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();

                state.chartResize.isResizing = true;
                state.chartResize.currentMainChart = mainChart;
                state.chartResize.currentVolumeChart = volumeChart;
                state.chartResize.startY = e.pageY;
                state.chartResize.startMainHeight = mainChart.offsetHeight;
                state.chartResize.startVolumeHeight = volumeChart.offsetHeight;

                resizeHandle.classList.add('resizing');
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
            });

            // Use existing global mousemove handler
            if (!state.chartResize.mouseMoveAttached) {
                document.addEventListener('mousemove', (e) => {
                    if (!state.chartResize.isResizing) return;

                    const diff = e.pageY - state.chartResize.startY;
                    const newMainHeight = state.chartResize.startMainHeight + diff;
                    const newVolumeHeight = state.chartResize.startVolumeHeight - diff;

                    // Enforce minimum heights
                    const minMainHeight = 300;
                    const minVolumeHeight = 100;

                    if (newMainHeight >= minMainHeight && newVolumeHeight >= minVolumeHeight) {
                        state.chartResize.currentMainChart.style.height = newMainHeight + 'px';
                        state.chartResize.currentMainChart.style.flex = 'none';
                        state.chartResize.currentVolumeChart.style.height = newVolumeHeight + 'px';
                        state.chartResize.currentVolumeChart.style.flex = 'none';

                        // Resize the TradingView charts
                        const chartData = state.charts.get(symbol);
                        if (chartData && chartData.chart) {
                            chartData.chart.applyOptions({
                                width: state.chartResize.currentMainChart.offsetWidth,
                                height: newMainHeight
                            });
                        }
                        if (chartData && chartData.volumeChart) {
                            chartData.volumeChart.applyOptions({
                                width: state.chartResize.currentVolumeChart.offsetWidth,
                                height: newVolumeHeight
                            });
                        }
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (state.chartResize.isResizing) {
                        state.chartResize.isResizing = false;
                        const resizeHandles = document.querySelectorAll('.chart-resize-handle');
                        resizeHandles.forEach(h => h.classList.remove('resizing'));
                        state.chartResize.currentMainChart = null;
                        state.chartResize.currentVolumeChart = null;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                });

                state.chartResize.mouseMoveAttached = true;
            }
        }

        // ========================================
        // SEARCH FUNCTIONALITY
        // ========================================

        function handleSearchKeypress(event) {
            if (event.key === 'Enter') {
                handleSearch();
            }
        }

        function handleSearch() {
            const input = document.getElementById('symbolSearch');
            const symbol = input.value.trim().toUpperCase();

            if (!symbol) {
                alert('Please enter a stock symbol');
                return;
            }

            // Check if chart already exists
            if (state.charts.has(symbol)) {
                activateChart(symbol);
                input.value = '';
                return;
            }

            // Create new chart panel
            createChartPanel(symbol);
            input.value = '';
        }

        // Create a new chart panel
        async function createChartPanel(symbol) {
            // Hide welcome message
            document.getElementById('welcomeMessage').style.display = 'none';

            // Fetch company name from backend
            let companyName = '';
            try {
                const response = await fetch(`cgi-bin/api/momentum_alerts_api.py?action=company_name&symbol=${symbol}`);
                const result = await response.json();
                if (result.success && result.company_name) {
                    companyName = result.company_name;
                }
            } catch (error) {
                console.error(`Failed to fetch company name for ${symbol}:`, error);
            }

            // Create display text for symbol (with company name if available)
            const symbolDisplay = companyName ? `${symbol} - ${companyName}` : symbol;

            // Create tab
            const tabBar = document.getElementById('tabBar');
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.id = `tab-${symbol}`;
            tab.onclick = () => activateChart(symbol);
            // Use symbolDisplay (with company name) in tab if available, otherwise just symbol
            const tabText = symbolDisplay || symbol;
            tab.innerHTML = `
                <span title="${tabText}">${symbol}</span>
                <span class="tab-close" onclick="closeChart('${symbol}', event)">√ó</span>
            `;
            tabBar.appendChild(tab);

            // Create chart panel
            const chartContainer = document.getElementById('chartContainer');
            const panel = document.createElement('div');
            panel.className = 'chart-panel';
            panel.id = `panel-${symbol}`;
            panel.innerHTML = `
                <!-- Chart Controls -->
                <div class="chart-controls">
                    <div class="control-group">
                        <label>Interval:</label>
                        <button class="control-btn active" onclick="setChartInterval('${symbol}', '1m')">1m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '5m')">5m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '30m')">30m</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '1h')">1h</button>
                        <button class="control-btn" onclick="setChartInterval('${symbol}', '1d')">1d</button>
                    </div>
                    <div class="control-group">
                        <label>Range:</label>
                        <button class="control-btn active" onclick="setRange('${symbol}', '1d')">1D</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '5d')">5D</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '1mo')">1M</button>
                        <button class="control-btn" onclick="setRange('${symbol}', '1y')">1Y</button>
                    </div>
                    <div class="control-group">
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'ema9', this.checked)">
                            EMA(9)
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'ema21', this.checked)">
                            EMA(21)
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'ema50', this.checked)">
                            EMA(50)
                        </label>
                        <label class="control-checkbox" id="vwap-label-${symbol}">
                            <input type="checkbox" id="vwap-checkbox-${symbol}" onchange="toggleIndicator('${symbol}', 'vwap', this.checked)">
                            VWAP <span class="indicator-note">(1D only)</span>
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" onchange="toggleIndicator('${symbol}', 'macd', this.checked)">
                            MACD
                        </label>
                        <label class="control-checkbox">
                            <input type="checkbox" checked onchange="toggleIndicator('${symbol}', 'volume', this.checked)">
                            Volume
                        </label>
                        <button class="save-settings-btn" id="save-btn-${symbol}" onclick="saveChartSettings('${symbol}')" title="Save chart settings">üíæ</button>
                    </div>
                </div>

                <!-- Chart Display -->
                <div class="chart-display">
                    <div class="chart-main">
                        <div class="loading active">
                            <div class="spinner"></div>
                            <div>Loading chart data for ${symbol}...</div>
                        </div>
                        <div class="canvas-container" id="canvas-${symbol}" style="display: none;">
                            <div class="main-chart" id="chart-${symbol}">
                                <div class="chart-legend" id="legend-${symbol}">
                                    <div class="legend-symbol">${symbolDisplay}</div>
                                    <div class="legend-price" id="legend-price-${symbol}">--</div>
                                    <div class="legend-details" id="legend-details-${symbol}">
                                        O: -- H: -- L: -- C: --
                                    </div>
                                    <div class="legend-volume" id="legend-volume-${symbol}"></div>
                                    <div class="legend-indicators" id="legend-indicators-${symbol}"></div>
                                </div>
                            </div>

                            <!-- Chart Resize Handle -->
                            <div class="chart-resize-handle" data-symbol="${symbol}"></div>

                            <div class="volume-chart" id="volume-${symbol}"></div>
                        </div>
                    </div>

                    <div class="resize-handle"></div>

                    <!-- Time and Sales Panel -->
                    <div class="time-sales-panel" id="time-sales-${symbol}">
                        <!-- Resize Handle -->
                        <div class="time-sales-resize" data-symbol="${symbol}"></div>

                        <div class="time-sales-header">
                            <span>Time & Sales - ${symbol}</span>
                        </div>
                        <div class="time-sales-list" id="trades-${symbol}">
                            <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                                Loading trades...
                            </div>
                        </div>
                    </div>
                </div>
            `;
            chartContainer.appendChild(panel);

            // Initialize Time & Sales resize for this panel
            initTimeSalesResize(symbol);

            // Initialize chart resize for this panel
            initChartResize(symbol);

            // Initialize chart data
            state.charts.set(symbol, {
                interval: '1m',
                range: '1d',
                companyName: companyName,  // Store company name for legend updates
                indicators: {
                    ema9: false,
                    ema21: false,
                    ema50: false,
                    vwap: false,
                    macd: false,
                    volume: true
                },
                chart: null,
                lastPrice: null
            });

            // Update legend with company name (if available)
            const legendSymbolElement = document.querySelector(`#legend-${symbol} .legend-symbol`);
            if (legendSymbolElement && companyName) {
                legendSymbolElement.textContent = `${symbol} - ${companyName}`;
            }

            // Activate the new chart
            activateChart(symbol);

            // Try to load saved global settings
            const savedSettings = loadChartSettings();
            if (savedSettings) {
                applyChartSettings(symbol, savedSettings);
            }

            // Load chart data
            loadChartData(symbol);

            // Start auto-update with adaptive refresh rate based on chart interval
            const getRefreshInterval = (interval) => {
                switch(interval) {
                    case '1m': return 30000;  // 30 seconds for 1-minute charts
                    case '5m': return 30000;  // 30 seconds for 5-minute charts
                    case '30m': return 30000; // 30 seconds for 30-minute charts
                    case '1h': return 60000;  // 60 seconds for hourly charts
                    case '1d': return 60000;  // 60 seconds for daily charts
                    default: return 30000;    // Default 30 seconds
                }
            };

            // Get chart data to determine refresh interval
            const chartData = state.charts.get(symbol);
            const refreshInterval = getRefreshInterval(chartData.interval);
            console.log(`Chart refresh interval for ${symbol} (${chartData.interval}): ${refreshInterval}ms`);
            const updateInterval = setInterval(() => loadChartData(symbol), refreshInterval);
            state.updateIntervals.set(symbol, updateInterval);

            // Load initial historical trades
            loadTimeSales(symbol);

            // Periodically refresh historical trades (every 2 seconds)
            // This ensures T&S updates even during after-hours/market closed
            const tradesInterval = setInterval(() => loadTimeSales(symbol), 2000);
            state.updateIntervals.set(`trades_${symbol}`, tradesInterval);

            // Subscribe to real-time trades via WebSocket
            subscribeToSymbol(symbol);
        }

        // Activate a chart panel
        function activateChart(symbol) {
            // Deactivate all tabs and panels
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.chart-panel').forEach(panel => panel.classList.remove('active'));

            // Activate selected tab and panel
            document.getElementById(`tab-${symbol}`).classList.add('active');
            document.getElementById(`panel-${symbol}`).classList.add('active');

            state.activeChart = symbol;
        }

        // Close a chart panel
        function closeChart(symbol, event) {
            event.stopPropagation();

            // Unsubscribe from real-time trades
            unsubscribeFromSymbol(symbol);

            // Clear intervals
            if (state.updateIntervals.has(symbol)) {
                clearInterval(state.updateIntervals.get(symbol));
                state.updateIntervals.delete(symbol);
            }
            // Clear trades polling interval
            if (state.updateIntervals.has(`trades_${symbol}`)) {
                clearInterval(state.updateIntervals.get(`trades_${symbol}`));
                state.updateIntervals.delete(`trades_${symbol}`);
            }
            if (state.timeSalesIntervals.has(symbol)) {
                clearInterval(state.timeSalesIntervals.get(symbol));
                state.timeSalesIntervals.delete(symbol);
            }

            // Clean up chart and resize observer
            const chartData = state.charts.get(symbol);
            if (chartData) {
                if (chartData.resizeObserver) {
                    chartData.resizeObserver.disconnect();
                }
                if (chartData.volumeResizeObserver) {
                    chartData.volumeResizeObserver.disconnect();
                }
                if (chartData.chart) {
                    chartData.chart.remove();
                }
                if (chartData.volumeChart) {
                    chartData.volumeChart.remove();
                }
            }

            // Remove tab and panel
            document.getElementById(`tab-${symbol}`).remove();
            document.getElementById(`panel-${symbol}`).remove();

            // Remove from state
            state.charts.delete(symbol);

            // Activate another chart if available
            if (state.charts.size > 0) {
                const firstSymbol = state.charts.keys().next().value;
                activateChart(firstSymbol);
            } else {
                // Show welcome message if no charts
                document.getElementById('welcomeMessage').style.display = 'block';
                state.activeChart = null;
            }
        }

        // Control functions
        function setChartInterval(symbol, interval) {
            const panel = document.getElementById(`panel-${symbol}`);
            if (!panel) return;

            panel.querySelectorAll('.control-group:nth-child(1) .control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            const chartData = state.charts.get(symbol);
            chartData.interval = interval;

            // Update the refresh interval based on new chart interval
            if (state.updateIntervals.has(symbol)) {
                clearInterval(state.updateIntervals.get(symbol));

                // Adaptive refresh rate based on interval
                const getRefreshInterval = (interval) => {
                    switch(interval) {
                        case '1m': return 30000;  // 30 seconds for 1-minute charts
                        case '5m': return 30000;  // 30 seconds for 5-minute charts
                        case '30m': return 30000; // 30 seconds for 30-minute charts
                        case '1h': return 60000;  // 60 seconds for hourly charts
                        case '1d': return 60000;  // 60 seconds for daily charts
                        default: return 30000;    // Default 30 seconds
                    }
                };

                const refreshInterval = getRefreshInterval(interval);
                console.log(`Updated refresh interval for ${symbol} (${interval}): ${refreshInterval}ms`);
                const updateInterval = setInterval(() => loadChartData(symbol), refreshInterval);
                state.updateIntervals.set(symbol, updateInterval);
            }

            loadChartData(symbol);
        }

        function setRange(symbol, range) {
            const panel = document.getElementById(`panel-${symbol}`);
            if (!panel) return;

            // Update button active states
            panel.querySelectorAll('.control-group:nth-child(2) .control-btn').forEach(btn => {
                btn.classList.remove('active');
                const btnText = btn.textContent;
                if ((btnText === '1D' && range === '1d') ||
                    (btnText === '5D' && range === '5d') ||
                    (btnText === '1M' && range === '1mo') ||
                    (btnText === '1Y' && range === '1y')) {
                    btn.classList.add('active');
                }
            });

            const chartData = state.charts.get(symbol);
            chartData.range = range;

            // Enable/disable VWAP based on range (only valid for 1D charts)
            const vwapCheckbox = document.getElementById(`vwap-checkbox-${symbol}`);
            const vwapLabel = document.getElementById(`vwap-label-${symbol}`);
            if (vwapCheckbox && vwapLabel) {
                if (range !== '1d') {
                    // Disable VWAP for non-1D ranges
                    vwapCheckbox.disabled = true;
                    vwapCheckbox.checked = false;
                    vwapLabel.style.opacity = '0.5';
                    chartData.indicators.vwap = false;
                } else {
                    // Enable VWAP for 1D range
                    vwapCheckbox.disabled = false;
                    vwapLabel.style.opacity = '1';
                }
            }

            // Force chart recreation when range changes to properly display new time scale
            chartData.forceRecreate = true;
            loadChartData(symbol);
        }

        function toggleIndicator(symbol, indicator, enabled) {
            const chartData = state.charts.get(symbol);
            chartData.indicators[indicator] = enabled;
            // Force chart recreation when indicators change
            chartData.forceRecreate = true;
            loadChartData(symbol);
        }

        // Save chart settings to localStorage (global for all symbols)
        function saveChartSettings(symbol) {
            const chartData = state.charts.get(symbol);
            if (!chartData) return;

            const settings = {
                interval: chartData.interval,
                range: chartData.range,
                indicators: chartData.indicators,
                savedAt: new Date().toISOString()
            };

            // Save to localStorage with global key (not symbol-specific)
            localStorage.setItem('chart_settings_global', JSON.stringify(settings));

            console.log('Saved global chart settings:', settings);

            // Visual feedback - flash all save buttons
            document.querySelectorAll('.save-settings-btn').forEach(btn => {
                btn.classList.add('saved');
            });
            setTimeout(() => {
                document.querySelectorAll('.save-settings-btn').forEach(btn => {
                    btn.classList.remove('saved');
                });
            }, 1000);

            updateStatus('Saved', 'Chart settings saved for all symbols');
        }

        // Load chart settings from localStorage (global for all symbols)
        function loadChartSettings() {
            try {
                const savedSettings = localStorage.getItem('chart_settings_global');
                if (!savedSettings) {
                    console.log('No saved global settings found');
                    return null;
                }

                const settings = JSON.parse(savedSettings);
                console.log('Loaded global chart settings:', settings);
                return settings;
            } catch (error) {
                console.error('Error loading global settings:', error);
                return null;
            }
        }

        // Apply saved settings to chart
        function applyChartSettings(symbol, settings) {
            if (!settings) return;

            const panel = document.getElementById(`panel-${symbol}`);
            if (!panel) return;

            const chartData = state.charts.get(symbol);
            if (!chartData) return;

            // Apply interval
            if (settings.interval) {
                chartData.interval = settings.interval;
                panel.querySelectorAll('.control-group:nth-child(1) .control-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.textContent === settings.interval) {
                        btn.classList.add('active');
                    }
                });
            }

            // Apply range
            if (settings.range) {
                chartData.range = settings.range;
                panel.querySelectorAll('.control-group:nth-child(2) .control-btn').forEach(btn => {
                    btn.classList.remove('active');
                    const btnText = btn.textContent;
                    if (btnText === settings.range ||
                        (btnText === '1D' && settings.range === '1d') ||
                        (btnText === '5D' && settings.range === '5d') ||
                        (btnText === '1M' && settings.range === '1mo') ||
                        (btnText === '1Y' && settings.range === '1y')) {
                        btn.classList.add('active');
                    }
                });
            }

            // Apply indicators
            if (settings.indicators) {
                chartData.indicators = { ...settings.indicators };

                // Disable VWAP if range is not 1D
                if (chartData.range !== '1d') {
                    chartData.indicators.vwap = false;
                }

                // Update checkboxes
                Object.keys(settings.indicators).forEach(indicator => {
                    const checkbox = panel.querySelector(`input[onchange*="'${indicator}'"]`);
                    if (checkbox) {
                        checkbox.checked = settings.indicators[indicator];
                    }
                });

                // Disable VWAP checkbox/label if not 1D range
                const vwapCheckbox = document.getElementById(`vwap-checkbox-${symbol}`);
                const vwapLabel = document.getElementById(`vwap-label-${symbol}`);
                if (vwapCheckbox && vwapLabel && chartData.range !== '1d') {
                    vwapCheckbox.disabled = true;
                    vwapCheckbox.checked = false;
                    vwapLabel.style.opacity = '0.5';
                }
            }

            console.log(`Applied settings for ${symbol}`);
        }

        // Load chart data from backend
        async function loadChartData(symbol) {
            const chartData = state.charts.get(symbol);
            if (!chartData) {
                console.error('Chart data not found for symbol:', symbol);
                return;
            }

            try {
                updateStatus('Loading', `Fetching data for ${symbol}...`);

                // Build API URL
                const indicators = Object.keys(chartData.indicators)
                    .filter(key => chartData.indicators[key])
                    .join(',');

                const apiUrl = `./cgi-bin/api/market_data_api.py?action=chart&symbol=${symbol}&interval=${chartData.interval}&range=${chartData.range}&indicators=${indicators}`;
                console.log('Loading chart from:', apiUrl);

                // Fetch data from backend API
                const response = await fetch(apiUrl);
                const result = await response.json();

                console.log('Chart response:', result);

                if (!result.success) {
                    throw new Error(result.error || 'Failed to fetch chart data');
                }

                const data = result.data;

                if (!data.bars || data.bars.length === 0) {
                    throw new Error('No chart data available');
                }

                console.log(`Processing ${data.bars.length} bars for chart`);
                console.log('Sample raw bar data:', data.bars[0]);

                // Convert bar data to candlestick format for TradingView Lightweight Charts
                // Note: Timestamps from API are already in Eastern Time (ET) with timezone info
                // Example: "2025-10-27T04:00:00-04:00" (4:00 AM EDT)
                //
                // IMPORTANT: TradingView charts display timestamps in UTC, so we need to convert
                // ET time components to a "fake" UTC timestamp that displays the correct ET time
                const candlesticks = data.bars.map(bar => {
                    const timestamp = bar.timestamp;
                    const date = new Date(timestamp);

                    // Extract date/time components in ET timezone
                    const etDateString = date.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });

                    // Parse the ET string (format: "MM/DD/YYYY, HH:mm:ss")
                    const [datePart, timePart] = etDateString.split(', ');
                    const [month, day, year] = datePart.split('/');
                    const [hour, minute, second] = timePart.split(':');

                    // Create Unix timestamp treating ET components as UTC
                    // This makes the chart display ET times correctly
                    const unixTime = Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);

                    // Debug first bar conversion
                    if (bar === data.bars[0]) {
                        console.log('First bar conversion:', {
                            raw_timestamp: timestamp,
                            et_string: etDateString,
                            unix_seconds: unixTime,
                            display_time: new Date(unixTime * 1000).toISOString()
                        });
                    }

                    return {
                        time: unixTime,
                        open: bar.open,
                        high: bar.high,
                        low: bar.low,
                        close: bar.close
                    };
                });

                console.log('Candlesticks prepared:', candlesticks.length);
                console.log('First candlestick:', candlesticks[0]);
                console.log('Last candlestick:', candlesticks[candlesticks.length - 1]);

                // Convert volume timestamps using the same ET timezone conversion
                // Color volume bars based on whether the bar closed up (green) or down (red)
                const volume = data.bars.map(bar => {
                    const date = new Date(bar.timestamp);
                    const etDateString = date.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    const [datePart, timePart] = etDateString.split(', ');
                    const [month, day, year] = datePart.split('/');
                    const [hour, minute, second] = timePart.split(':');
                    const unixTime = Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);

                    // Determine color: green if close >= open, red if close < open
                    const color = bar.close >= bar.open ? '#4ecca3' : '#ff6b6b';

                    return {
                        time: unixTime,
                        value: bar.volume,
                        color: color
                    };
                });

                renderChart(symbol, {
                    candlesticks,
                    indicators: data.indicators || {},
                    volume: volume
                });

                updateStatus('Connected', `${symbol} updated`);
                document.getElementById('updateTime').textContent =
                    `Last updated: ${new Date().toLocaleTimeString()}`;

            } catch (error) {
                console.error('Error loading chart data:', error);
                updateStatus('Error', `Failed to load data for ${symbol}: ${error.message}`);
            }
        }

        // Render chart
        function renderChart(symbol, data) {
            console.log('renderChart called for', symbol, 'with', data.candlesticks.length, 'candlesticks');

            const canvasContainer = document.getElementById(`canvas-${symbol}`);
            if (!canvasContainer) {
                console.error('Canvas container not found for', symbol);
                return;
            }

            const loading = canvasContainer.previousElementSibling;
            if (loading) {
                loading.classList.remove('active');
            }
            canvasContainer.style.display = 'block';

            const chartElement = document.getElementById(`chart-${symbol}`);
            if (!chartElement) {
                console.error('Chart element not found for', symbol);
                return;
            }

            const chartData = state.charts.get(symbol);
            if (!chartData) {
                console.error('Chart data state not found for', symbol);
                return;
            }

            // If chart already exists, just update the data instead of destroying/recreating
            // (unless indicators changed, which requires recreation)
            if (chartData.chart && chartData.candlestickSeries && !chartData.forceRecreate) {
                console.log('Updating existing chart with new data');

                // Update candlestick data
                chartData.candlestickSeries.setData(data.candlesticks);

                // Update legend with latest bar
                if (data.candlesticks.length > 0) {
                    const latestBar = data.candlesticks[data.candlesticks.length - 1];
                    updateLegendWithBar(symbol, latestBar);
                }

                // Helper function to convert timestamps
                function convertTimestampToET(timestamp) {
                    const date = new Date(timestamp);
                    const etDateString = date.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                    const [datePart, timePart] = etDateString.split(', ');
                    const [month, day, year] = datePart.split('/');
                    const [hour, minute, second] = timePart.split(':');
                    return Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);
                }

                // Update indicators
                const indicators = data.indicators || {};

                // Update EMA indicators
                if (chartData.indicatorSeries.ema9 && indicators.ema9) {
                    const ema9Data = indicators.ema9
                        .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                        .map(item => ({
                            time: convertTimestampToET(item.time),
                            value: item.value
                        }));
                    chartData.indicatorSeries.ema9.setData(ema9Data);
                }

                if (chartData.indicatorSeries.ema21 && indicators.ema21) {
                    const ema21Data = indicators.ema21
                        .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                        .map(item => ({
                            time: convertTimestampToET(item.time),
                            value: item.value
                        }));
                    chartData.indicatorSeries.ema21.setData(ema21Data);
                }

                if (chartData.indicatorSeries.ema50 && indicators.ema50) {
                    const ema50Data = indicators.ema50
                        .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                        .map(item => ({
                            time: convertTimestampToET(item.time),
                            value: item.value
                        }));
                    chartData.indicatorSeries.ema50.setData(ema50Data);
                }

                if (chartData.indicatorSeries.vwap && indicators.vwap) {
                    const vwapData = indicators.vwap
                        .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                        .map(item => ({
                            time: convertTimestampToET(item.time),
                            value: item.value
                        }));
                    chartData.indicatorSeries.vwap.setData(vwapData);
                }

                // Update volume chart
                if (chartData.indicatorSeries.volume && data.volume) {
                    chartData.indicatorSeries.volume.setData(data.volume);
                }

                console.log('Chart data updated without recreation');
                return;
            }

            // Chart doesn't exist yet, create it (or needs recreation due to indicator changes)
            if (chartData.chart) {
                console.log('Removing existing chart for recreation');

                // Clear the forceRecreate flag
                chartData.forceRecreate = false;

                // Save current zoom/pan state before destroying chart
                try {
                    const currentRange = chartData.chart.timeScale().getVisibleLogicalRange();
                    if (currentRange) {
                        chartData.savedZoomState = currentRange;
                        console.log('Saved zoom state:', currentRange);
                    }
                } catch (error) {
                    console.warn('Could not save zoom state:', error);
                }

                if (chartData.resizeObserver) {
                    chartData.resizeObserver.disconnect();
                    chartData.resizeObserver = null;
                }
                if (chartData.volumeResizeObserver) {
                    chartData.volumeResizeObserver.disconnect();
                    chartData.volumeResizeObserver = null;
                }
                chartData.chart.remove();
                chartData.chart = null;
                if (chartData.volumeChart) {
                    chartData.volumeChart.remove();
                    chartData.volumeChart = null;
                }
            }

            // Wait for layout to complete before creating chart
            // This fixes the "chart appears then disappears" bug caused by 0x0 dimensions
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    createChart(chartElement, chartData, symbol, data);
                });
            });
        }

        // Create the actual chart (separated to handle async layout)
        function createChart(chartElement, chartData, symbol, data) {
            console.log('=== CREATE CHART CALLED ===');
            console.log('Chart element dimensions:', chartElement.clientWidth, 'x', chartElement.clientHeight);
            console.log('Candlesticks to render:', data.candlesticks.length);
            console.log('First 3 candlesticks:', data.candlesticks.slice(0, 3));

            // Check if element has dimensions
            if (chartElement.clientWidth === 0 || chartElement.clientHeight === 0) {
                console.error('Chart element has zero dimensions! Cannot create chart.');
                // Try again after a short delay
                setTimeout(() => {
                    console.log('Retrying chart creation after delay...');
                    createChart(chartElement, chartData, symbol, data);
                }, 100);
                return;
            }

            // Create new Lightweight Charts instance
            console.log('=== CREATING MAIN CHART ===');
            console.log('Main chart element ID:', chartElement.id);
            console.log('Main chart dimensions:', chartElement.clientWidth, 'x', chartElement.clientHeight);
            const chart = LightweightCharts.createChart(chartElement, {
                width: chartElement.clientWidth,
                height: chartElement.clientHeight,
                layout: {
                    background: { color: '#1a1a2e' },
                    textColor: '#d1d4dc',  // Brighter text for better visibility
                },
                grid: {
                    vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                    horzLines: { color: 'rgba(255, 255, 255, 0.1)' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: 'rgba(255, 255, 255, 0.2)',
                },
                timeScale: {
                    borderColor: 'rgba(255, 255, 255, 0.8)',  // Much brighter border
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            // Force timeScale to be visible with bright colors
            console.log('Forcing timeScale visibility...');
            chart.applyOptions({
                layout: {
                    textColor: '#ffffff',  // Pure white for maximum visibility
                },
                timeScale: {
                    visible: true,
                    timeVisible: true,
                    secondsVisible: false,
                    borderColor: '#ffffff',  // Pure white border
                }
            });
            const timeScale = chart.timeScale();
            console.log('TimeScale object:', timeScale);
            console.log('Full TimeScale options:', timeScale.options());

            // Add candlestick series
            console.log('Adding candlestick series...');
            const candlestickSeries = chart.addCandlestickSeries({
                upColor: '#4ecca3',
                downColor: '#ff6b6b',
                borderVisible: false,
                wickUpColor: '#4ecca3',
                wickDownColor: '#ff6b6b',
                lastValueVisible: false,  // Hide price label on right side
                priceLineVisible: false   // Hide horizontal price line
            });

            // Set the candlestick data
            console.log('Setting candlestick data:', data.candlesticks.length, 'bars');
            if (data.candlesticks.length > 0) {
                console.log('First bar:', data.candlesticks[0]);
                console.log('Last bar:', data.candlesticks[data.candlesticks.length - 1]);
            }
            candlestickSeries.setData(data.candlesticks);
            console.log('Candlestick data set successfully');

            // Store chart reference
            chartData.chart = chart;
            chartData.candlestickSeries = candlestickSeries;
            chartData.indicatorSeries = {};

            // Update legend on crosshair move
            chart.subscribeCrosshairMove((param) => {
                updateLegend(symbol, param, candlestickSeries, data.candlesticks, chartData);
            });

            // Initialize legend with latest bar
            if (data.candlesticks.length > 0) {
                const latestBar = data.candlesticks[data.candlesticks.length - 1];
                updateLegendWithBar(symbol, latestBar);
            }

            // Helper function to convert timestamps from ET to display correctly in UTC charts
            function convertTimestampToET(timestamp) {
                const date = new Date(timestamp);
                const etDateString = date.toLocaleString('en-US', {
                    timeZone: 'America/New_York',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                const [datePart, timePart] = etDateString.split(', ');
                const [month, day, year] = datePart.split('/');
                const [hour, minute, second] = timePart.split(':');
                return Math.floor(Date.UTC(year, month - 1, day, hour, minute, second) / 1000);
            }

            // Add indicator series if available
            const indicators = data.indicators || {};

            // EMA indicators
            if (indicators.ema9 && indicators.ema9.length > 0) {
                const ema9Series = chart.addLineSeries({
                    color: '#2962FF',
                    lineWidth: 2,
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const ema9Data = indicators.ema9
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                console.log(`EMA(9): Filtered ${indicators.ema9.length} -> ${ema9Data.length} data points`);
                if (ema9Data.length > 0) {
                    console.log('EMA(9) first/last values:', ema9Data[0].value, ema9Data[ema9Data.length-1].value);
                }
                ema9Series.setData(ema9Data);
                chartData.indicatorSeries.ema9 = ema9Series;
            }

            if (indicators.ema21 && indicators.ema21.length > 0) {
                const ema21Series = chart.addLineSeries({
                    color: '#FF6D00',
                    lineWidth: 2,
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const ema21Data = indicators.ema21
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                ema21Series.setData(ema21Data);
                chartData.indicatorSeries.ema21 = ema21Series;
            }

            if (indicators.ema50 && indicators.ema50.length > 0) {
                const ema50Series = chart.addLineSeries({
                    color: '#00E676',
                    lineWidth: 2,
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const ema50Data = indicators.ema50
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                ema50Series.setData(ema50Data);
                chartData.indicatorSeries.ema50 = ema50Series;
            }

            if (indicators.ema200 && indicators.ema200.length > 0) {
                const ema200Series = chart.addLineSeries({
                    color: '#D500F9',
                    lineWidth: 2,
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const ema200Data = indicators.ema200
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                ema200Series.setData(ema200Data);
                chartData.indicatorSeries.ema200 = ema200Series;
            }

            // VWAP indicator
            if (indicators.vwap && indicators.vwap.length > 0) {
                const vwapSeries = chart.addLineSeries({
                    color: '#FFD600',
                    lineWidth: 2,
                    lineStyle: 2, // Dashed line
                    lastValueVisible: false,  // Hide the price label on right side
                    priceLineVisible: false   // Hide the horizontal price line
                });
                const vwapData = indicators.vwap
                    .filter(item => item.value != null && !isNaN(item.value) && isFinite(item.value))
                    .map(item => ({
                        time: convertTimestampToET(item.time),
                        value: item.value
                    }));
                console.log(`VWAP: Filtered ${indicators.vwap.length} -> ${vwapData.length} data points`);
                if (vwapData.length > 0) {
                    console.log('VWAP first/last values:', vwapData[0].value, vwapData[vwapData.length-1].value);
                }
                vwapSeries.setData(vwapData);
                chartData.indicatorSeries.vwap = vwapSeries;
            }

            // Create separate volume chart
            if (chartData.indicators.volume && data.volume && data.volume.length > 0) {
                const volumeElement = document.getElementById(`volume-${symbol}`);
                if (volumeElement) {
                    console.log('=== CREATING VOLUME CHART ===');
                    console.log('Volume chart element ID:', volumeElement.id);
                    console.log('Volume chart dimensions:', volumeElement.clientWidth, 'x', volumeElement.clientHeight);
                    console.log('Volume element parent:', volumeElement.parentElement.id);

                    // Check if volume element has dimensions
                    if (volumeElement.clientWidth === 0 || volumeElement.clientHeight === 0) {
                        console.warn('Volume chart element has zero dimensions! Width:', volumeElement.clientWidth, 'Height:', volumeElement.clientHeight);
                        // Continue anyway - ResizeObserver will fix it when it gets dimensions
                    }

                    const volumeChart = LightweightCharts.createChart(volumeElement, {
                        width: volumeElement.clientWidth,
                        height: volumeElement.clientHeight,
                        layout: {
                            background: { color: '#1a1a2e' },
                            textColor: '#d1d4dc',
                        },
                        grid: {
                            vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                            horzLines: { color: 'rgba(255, 255, 255, 0.1)' },
                        },
                        rightPriceScale: {
                            borderColor: 'rgba(255, 255, 255, 0.2)',
                        },
                        timeScale: {
                            borderColor: 'rgba(255, 255, 255, 0.8)',
                            timeVisible: true,
                            secondsVisible: false,
                        },
                    });

                    const volumeSeries = volumeChart.addHistogramSeries({
                        priceFormat: {
                            type: 'volume',
                        },
                        lastValueVisible: false,  // Hide volume label on right side
                        priceLineVisible: false   // Hide horizontal price line
                    });
                    volumeSeries.setData(data.volume);

                    // Store volume chart reference
                    chartData.volumeChart = volumeChart;
                    chartData.indicatorSeries.volume = volumeSeries;

                    // Sync time scales between main chart and volume chart
                    // Use flags to prevent infinite loop
                    let syncingToVolume = false;
                    let syncingToMain = false;

                    chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                        if (syncingToMain) return;
                        const range = chart.timeScale().getVisibleLogicalRange();
                        if (range) {
                            syncingToVolume = true;
                            volumeChart.timeScale().setVisibleLogicalRange(range);
                            syncingToVolume = false;
                            // Save zoom state whenever user changes it
                            chartData.savedZoomState = range;
                        }
                    });

                    volumeChart.timeScale().subscribeVisibleTimeRangeChange(() => {
                        if (syncingToVolume) return;
                        const range = volumeChart.timeScale().getVisibleLogicalRange();
                        if (range) {
                            syncingToMain = true;
                            chart.timeScale().setVisibleLogicalRange(range);
                            syncingToMain = false;
                            // Save zoom state whenever user changes it
                            chartData.savedZoomState = range;
                        }
                    });

                    // Handle volume chart resize
                    const volumeResizeObserver = new ResizeObserver(entries => {
                        if (entries.length === 0) return;
                        const { width, height } = entries[0].contentRect;
                        volumeChart.applyOptions({ width, height });
                    });
                    volumeResizeObserver.observe(volumeElement);

                    // Store for cleanup
                    chartData.volumeResizeObserver = volumeResizeObserver;
                }
            } else {
                // If no volume chart, still track zoom state changes on main chart
                chart.timeScale().subscribeVisibleTimeRangeChange(() => {
                    const range = chart.timeScale().getVisibleLogicalRange();
                    if (range) {
                        chartData.savedZoomState = range;
                    }
                });
            }

            // Handle window resize
            const resizeObserver = new ResizeObserver(entries => {
                if (entries.length === 0) return;
                const { width, height } = entries[0].contentRect;
                chart.applyOptions({ width, height });
            });
            resizeObserver.observe(chartElement);

            // Store resize observer for cleanup
            chartData.resizeObserver = resizeObserver;

            // Restore saved zoom state or set default view
            const barsCount = data.candlesticks.length;
            if (barsCount > 0) {
                if (chartData.savedZoomState) {
                    // Restore previous zoom/pan state
                    console.log('Restoring saved zoom state:', chartData.savedZoomState);
                    try {
                        chart.timeScale().setVisibleLogicalRange(chartData.savedZoomState);
                        console.log('Zoom state restored successfully');
                    } catch (error) {
                        console.warn('Could not restore zoom state, using default:', error);
                        // Fall back to default view
                        const visibleBars = Math.min(100, barsCount);
                        chart.timeScale().setVisibleLogicalRange({
                            from: barsCount - visibleBars,
                            to: barsCount - 1
                        });
                    }
                } else {
                    // Show last 100 bars (or all bars if less than 100) for new charts
                    const visibleBars = Math.min(100, barsCount);
                    chart.timeScale().setVisibleLogicalRange({
                        from: barsCount - visibleBars,
                        to: barsCount - 1
                    });
                    console.log('TimeScale set to show bars', barsCount - visibleBars, 'to', barsCount - 1);
                }
                console.log('TimeScale options:', chart.timeScale().options());
            }

            // Debug: Check if chart is actually visible in DOM
            console.log('Chart element parent dimensions:', chartElement.parentElement.clientWidth, 'x', chartElement.parentElement.clientHeight);
            console.log('Chart element computed style:', window.getComputedStyle(chartElement).display);

            // Check if timeScale element exists in DOM
            setTimeout(() => {
                const allTables = chartElement.querySelectorAll('table');
                console.log('Found', allTables.length, 'table elements in chart');

                if (allTables.length > 0) {
                    const table = allTables[0];
                    const rows = table.querySelectorAll('tr');
                    console.log('Found', rows.length, 'table rows');

                    if (rows.length > 1) {
                        console.log('Row 0 (main chart) height:', rows[0].querySelector('td')?.style.height);
                        console.log('Row 1 (timeScale) height:', rows[1].querySelector('td')?.style.height);

                        // Check the canvas in the timeScale row
                        const timeScaleCanvas = rows[1].querySelector('canvas');
                        if (timeScaleCanvas) {
                            console.log('TimeScale canvas found! Dimensions:', timeScaleCanvas.width, 'x', timeScaleCanvas.height);
                            console.log('TimeScale canvas style:', timeScaleCanvas.style.cssText);
                        } else {
                            console.log('No canvas found in timeScale row!');
                        }
                    }
                }
            }, 500);
        }

        // Load time and sales data
        async function loadTimeSales(symbol) {
            const container = document.getElementById(`trades-${symbol}`);
            if (!container) {
                console.error(`Time & sales container not found for ${symbol}`);
                return;
            }

            // Only show loading state on initial load (when container is empty or has placeholder)
            // Don't show loading if "No recent trades" is already displayed
            const isInitialLoad = container.children.length === 0 ||
                                  container.textContent.includes('Loading');

            if (isInitialLoad) {
                container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                    Loading trades...
                </div>`;
            }

            try {
                const apiUrl = `./cgi-bin/api/market_data_api.py?action=trades&symbol=${symbol}&limit=250`;
                console.log('Loading trades from:', apiUrl);

                const response = await fetch(apiUrl);

                // Check if response is ok
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();

                console.log('Trades response for', symbol, ':', result);

                if (!result.success) {
                    console.error('Error loading trades for', symbol, ':', result.error);
                    container.innerHTML = `<div style="text-align: center; color: var(--accent-red); padding: 20px;">
                        Error: ${result.error || 'Failed to load trades'}
                    </div>`;
                    return;
                }

                if (!result.data || !result.data.trades || result.data.trades.length === 0) {
                    console.warn('No trades available for', symbol);
                    container.innerHTML = `<div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                        No recent trades available for ${symbol}
                    </div>`;
                    return;
                }

                console.log(`Got ${result.data.trades.length} trades for ${symbol}`);
                renderTimeSales(symbol, result.data.trades);
            } catch (error) {
                console.error('Error loading time & sales for', symbol, ':', error);
                container.innerHTML = `<div style="text-align: center; color: var(--accent-red); padding: 20px;">
                    Failed to load trades: ${error.message}
                </div>`;
            }
        }

        // Render time and sales
        function renderTimeSales(symbol, trades) {
            const container = document.getElementById(`trades-${symbol}`);
            const chartData = state.charts.get(symbol);

            if (!container || !chartData) {
                console.error('Cannot render trades - container or chartData missing');
                return;
            }

            console.log(`Rendering ${trades.length} trades for ${symbol}`);

            // Debug: Log first and last trade timestamps
            if (trades.length > 0) {
                const now = new Date();
                const oldestTrade = new Date(trades[0].timestamp);
                const newestTrade = new Date(trades[trades.length - 1].timestamp);
                const ageMinutes = Math.round((now - newestTrade) / 1000 / 60);
                console.log(`Trade age: Most recent trade is ${ageMinutes} minutes old`);
                console.log(`Oldest trade: ${oldestTrade.toISOString()}`);
                console.log(`Newest trade: ${newestTrade.toISOString()}`);
                console.log(`Current time: ${now.toISOString()}`);
            }

            // Reverse trades so newest are at the top
            const reversedTrades = [...trades].reverse();

            container.innerHTML = reversedTrades.map(trade => {
                const priceClass = chartData.lastPrice && trade.price > chartData.lastPrice ? 'up' :
                                  chartData.lastPrice && trade.price < chartData.lastPrice ? 'down' : '';

                // Format time in ET timezone (backend returns ISO strings with ET offset)
                const tradeDate = new Date(trade.timestamp);
                const tradeTime = tradeDate.toLocaleTimeString('en-US', {
                    timeZone: 'America/New_York',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });

                return `
                    <div class="trade-item">
                        <div>
                            <div class="trade-time">${tradeTime} ET</div>
                            <div class="trade-price ${priceClass}">$${trade.price.toFixed(2)}</div>
                        </div>
                        <div class="trade-size">${trade.size.toLocaleString()}</div>
                    </div>
                `;
            }).join('');

            if (trades.length > 0) {
                // Use the most recent trade (last in original array, first in reversed)
                chartData.lastPrice = trades[trades.length - 1].price;
            }


            // Auto-scroll to top to show newest trades
            container.scrollTop = 0;
        }

        // Update status bar
        function updateStatus(status, message) {
            document.getElementById('statusText').textContent = `${status}: ${message}`;
        }

        // Update legend with bar data
        function updateLegendWithBar(symbol, bar, indicatorValues, volumeValue) {
            const priceElement = document.getElementById(`legend-price-${symbol}`);
            const detailsElement = document.getElementById(`legend-details-${symbol}`);
            const volumeElement = document.getElementById(`legend-volume-${symbol}`);
            const symbolElement = document.querySelector(`#legend-${symbol} .legend-symbol`);

            if (!priceElement || !detailsElement) return;

            // Update symbol display with company name if available
            const chartData = state.charts.get(symbol);
            if (symbolElement && chartData && chartData.companyName) {
                symbolElement.textContent = `${symbol} - ${chartData.companyName}`;
            }

            const isUp = bar.close >= bar.open;
            const change = bar.close - bar.open;
            const changePercent = bar.open > 0 ? (change / bar.open * 100) : 0;

            priceElement.className = `legend-price ${isUp ? 'up' : 'down'}`;
            priceElement.innerHTML = `$${bar.close.toFixed(2)} <span class="legend-change">${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)</span>`;

            detailsElement.textContent = `O: $${bar.open.toFixed(2)} H: $${bar.high.toFixed(2)} L: $${bar.low.toFixed(2)} C: $${bar.close.toFixed(2)}`;

            // Update volume in legend
            if (volumeElement && volumeValue !== undefined && volumeValue !== null) {
                const formattedVolume = volumeValue.toLocaleString();
                volumeElement.innerHTML = `Vol: <span class="legend-volume-value">${formattedVolume}</span>`;
            }

            // Update indicator values in legend
            if (indicatorValues) {
                updateLegendIndicators(symbol, indicatorValues);
            }
        }

        // Update indicator values in legend
        function updateLegendIndicators(symbol, indicatorValues) {
            const indicatorsElement = document.getElementById(`legend-indicators-${symbol}`);
            if (!indicatorsElement) return;

            const indicatorConfigs = {
                ema9: { label: 'EMA(9)', color: '#2962FF' },
                ema21: { label: 'EMA(21)', color: '#FF6D00' },
                ema50: { label: 'EMA(50)', color: '#00E676' },
                ema200: { label: 'EMA(200)', color: '#D500F9' },
                vwap: { label: 'VWAP', color: '#FFD600' }
            };

            let html = '';
            for (const [key, config] of Object.entries(indicatorConfigs)) {
                if (indicatorValues[key] !== undefined && indicatorValues[key] !== null) {
                    html += `
                        <div class="legend-indicator-item">
                            <span class="legend-indicator-color" style="background-color: ${config.color};"></span>
                            <span class="legend-indicator-label">${config.label}:</span>
                            <span class="legend-indicator-value">$${indicatorValues[key].toFixed(2)}</span>
                        </div>
                    `;
                }
            }

            indicatorsElement.innerHTML = html;
        }

        // Update legend on crosshair move
        function updateLegend(symbol, param, candlestickSeries, candlesticks, chartData) {
            if (!param.time) {
                // No bar under crosshair, show latest bar
                if (candlesticks.length > 0) {
                    const latestBar = candlesticks[candlesticks.length - 1];
                    const indicatorValues = getLatestIndicatorValues(chartData);
                    updateLegendWithBar(symbol, latestBar, indicatorValues);
                }
                return;
            }

            const data = param.seriesData.get(candlestickSeries);
            if (data) {
                // Get indicator values at crosshair position
                const indicatorValues = {};
                let volumeValue = null;

                if (chartData && chartData.indicatorSeries) {
                    for (const [key, series] of Object.entries(chartData.indicatorSeries)) {
                        if (series && param.seriesData.has(series)) {
                            const value = param.seriesData.get(series);
                            if (value && value.value !== undefined) {
                                if (key === 'volume') {
                                    volumeValue = value.value;
                                } else {
                                    indicatorValues[key] = value.value;
                                }
                            }
                        }
                    }
                }
                updateLegendWithBar(symbol, data, indicatorValues, volumeValue);
            }
        }

        // Get latest indicator values
        function getLatestIndicatorValues(chartData) {
            const values = {};
            if (!chartData || !chartData.indicatorSeries) return values;

            // This will be populated when indicators update
            // For now, we'll get values from crosshair events
            return values;
        }

        // Mock data generators (to be replaced with backend calls)
        function generateMockData(symbol, interval, range) {
            const candlesticks = [];
            const numBars = range === '1d' ? 390 : range === '5d' ? 1950 : 100;
            let basePrice = 150 + Math.random() * 50;

            for (let i = 0; i < numBars; i++) {
                // Lightweight Charts requires Unix timestamp in SECONDS (not milliseconds)
                const timeMs = Date.now() - (numBars - i) * 60000;
                const time = Math.floor(timeMs / 1000);

                const open = basePrice;
                const close = basePrice + (Math.random() - 0.5) * 5;
                const high = Math.max(open, close) + Math.random() * 2;
                const low = Math.min(open, close) - Math.random() * 2;

                candlesticks.push({
                    time: time,
                    open: Number(open.toFixed(2)),
                    high: Number(high.toFixed(2)),
                    low: Number(low.toFixed(2)),
                    close: Number(close.toFixed(2))
                });

                basePrice = close;
            }

            return { candlesticks };
        }

        function generateMockTrades(symbol) {
            const trades = [];
            let basePrice = 150 + Math.random() * 50;

            for (let i = 0; i < 20; i++) {
                const price = basePrice + (Math.random() - 0.5) * 2;
                trades.push({
                    timestamp: new Date(Date.now() - (20 - i) * 5000),
                    price: price,
                    size: Math.floor(Math.random() * 1000) + 100
                });
                basePrice = price;
            }

            return trades.reverse();
        }

        // ========================================
        // WATCH LIST FUNCTIONALITY
        // ========================================

        // Watch list state
        const watchListState = {
            symbols: [],
            manualSymbols: new Set(),  // Track manually added symbols
            deletedSymbols: new Set(), // Track deleted symbols (to hide on auto-refresh)
            refreshInterval: null
        };

        // Initialize watch list on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadWatchList();
            // Refresh watch list every 2 minutes (for testing)
            watchListState.refreshInterval = setInterval(loadWatchList, 120000);
        });

        // Load watch list from API
        async function loadWatchList() {
            try {
                console.log('Loading watch list from API...');
                const response = await fetch('cgi-bin/api/watch_list_api.py');
                console.log('Watch list API response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Watch list data received:', data);

                if (data.success) {
                    // Filter out deleted symbols (unless they were manually re-added)
                    watchListState.symbols = data.data.filter(symbol => {
                        // Keep if NOT deleted, OR if deleted but manually re-added
                        return !watchListState.deletedSymbols.has(symbol.symbol) ||
                               watchListState.manualSymbols.has(symbol.symbol);
                    });

                    // Also add back any manual symbols that aren't in the API response
                    const apiSymbols = new Set(data.data.map(s => s.symbol));
                    watchListState.manualSymbols.forEach(manualSymbol => {
                        if (!apiSymbols.has(manualSymbol) && !watchListState.symbols.find(s => s.symbol === manualSymbol)) {
                            // Add manual symbol if it's not already in the list
                            watchListState.symbols.push({
                                symbol: manualSymbol,
                                oracle: false,
                                manual: true,
                                top_gainers: false,
                                surge: false
                            });
                        }
                    });

                    // Sort alphabetically
                    watchListState.symbols.sort((a, b) => a.symbol.localeCompare(b.symbol));

                    console.log(`Loaded ${watchListState.symbols.length} symbols from watch list (${data.count} from API, ${watchListState.deletedSymbols.size} deleted, ${watchListState.manualSymbols.size} manual)`);
                    renderWatchList();
                } else {
                    console.error('Failed to load watch list:', data.error);
                    showWatchListError(`Failed to load watch list: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error loading watch list:', error);
                showWatchListError(`Error loading watch list: ${error.message}`);
            }
        }

        // Render watch list table
        function renderWatchList() {
            const tbody = document.getElementById('watchListBody');

            if (!watchListState.symbols || watchListState.symbols.length === 0) {
                tbody.innerHTML = `
                    <tr class="watch-list-empty">
                        <td colspan="6">No symbols in watch list</td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = watchListState.symbols.map(symbol => `
                <tr ondblclick="openChartFromWatchList('${symbol.symbol}')">
                    <td class="symbol-cell">${symbol.symbol}</td>
                    <td class="source-cell">
                        <span class="source-indicator ${symbol.oracle ? 'on' : 'off'}"
                              title="${symbol.oracle ? 'Oracle: Yes' : 'Oracle: No'}"></span>
                    </td>
                    <td class="source-cell">
                        <span class="source-indicator ${symbol.manual ? 'on' : 'off'}"
                              title="${symbol.manual ? 'Manual: Yes' : 'Manual: No'}"></span>
                    </td>
                    <td class="source-cell">
                        <span class="source-indicator ${symbol.top_gainers ? 'on' : 'off'}"
                              title="${symbol.top_gainers ? 'Top Gainers: Yes' : 'Top Gainers: No'}"></span>
                    </td>
                    <td class="source-cell">
                        <span class="source-indicator ${symbol.surge ? 'on' : 'off'}"
                              title="${symbol.surge ? 'Volume Surge: Yes' : 'Volume Surge: No'}"></span>
                    </td>
                    <td class="del-cell">
                        <button class="delete-btn"
                                onclick="event.stopPropagation(); deleteSymbolFromWatchList('${symbol.symbol}')"
                                title="Delete ${symbol.symbol}">
                            üóëÔ∏è
                        </button>
                    </td>
                </tr>
            `).join('');
        }

        // Show watch list error
        function showWatchListError(message) {
            const tbody = document.getElementById('watchListBody');
            tbody.innerHTML = `
                <tr class="watch-list-empty">
                    <td colspan="6" style="color: var(--accent-red);">${message}</td>
                </tr>
            `;
        }

        // Open chart from watch list (double-click)
        function openChartFromWatchList(symbol) {
            if (!symbol) return;

            console.log(`Opening chart for ${symbol} from watch list`);

            // Set search input value
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.value = symbol.toUpperCase();
            }

            // Open chart
            handleSearch();
        }

        // Handle keypress in watch list add input
        function handleWatchListKeypress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                addSymbolToWatchList();
            }
        }

        // Add symbol to watch list
        async function addSymbolToWatchList() {
            const input = document.getElementById('watchListAddInput');
            if (!input) return;

            const symbol = input.value.trim().toUpperCase();

            if (!symbol) {
                return;
            }

            // Check if symbol already exists
            const existingSymbol = watchListState.symbols.find(s => s.symbol === symbol);
            if (existingSymbol) {
                // Mark existing symbol as manually added
                existingSymbol.manual = true;
                watchListState.manualSymbols.add(symbol);

                // Re-render to show the manual indicator
                renderWatchList();
                input.value = '';

                console.log(`Symbol ${symbol} already in watch list, marked as manual`);

                // Send to backend API to be monitored by momentum_alerts.py
                try {
                    const response = await fetch('cgi-bin/api/manual_symbols_api.py', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ symbol: symbol })
                    });

                    const result = await response.json();

                    if (result.success) {
                        console.log(`‚úÖ Symbol ${symbol} sent to momentum_alerts.py for monitoring`);
                    } else {
                        console.error(`‚ùå Failed to send ${symbol} to backend:`, result.error);
                    }
                } catch (error) {
                    console.error(`‚ùå Error sending ${symbol} to backend:`, error);
                }

                return;
            }

            // If this symbol was previously deleted, remove it from deleted set
            // This allows it to show up again even after auto-refresh
            if (watchListState.deletedSymbols.has(symbol)) {
                watchListState.deletedSymbols.delete(symbol);
                console.log(`Symbol ${symbol} was previously deleted, now re-adding as manual`);
            }

            // Add symbol to list
            const newSymbol = {
                symbol: symbol,
                oracle: false,
                manual: true,
                top_gainers: false,
                surge: false
            };

            watchListState.symbols.push(newSymbol);
            watchListState.manualSymbols.add(symbol);

            // Re-sort symbols
            watchListState.symbols.sort((a, b) => a.symbol.localeCompare(b.symbol));

            // Render and clear input
            renderWatchList();
            input.value = '';

            console.log(`Added ${symbol} to watch list (manual symbols: ${watchListState.manualSymbols.size})`);

            // Send to backend API to be monitored by momentum_alerts.py
            try {
                const response = await fetch('cgi-bin/api/manual_symbols_api.py', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ symbol: symbol })
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`‚úÖ Symbol ${symbol} sent to momentum_alerts.py for monitoring`);
                } else {
                    console.error(`‚ùå Failed to send ${symbol} to backend:`, result.error);
                }
            } catch (error) {
                console.error(`‚ùå Error sending ${symbol} to backend:`, error);
            }
        }

        // Delete symbol from watch list
        async function deleteSymbolFromWatchList(symbol) {
            if (!symbol) return;

            console.log(`Deleting ${symbol} from watch list`);

            // Check if this is a manually added symbol
            const isManual = watchListState.manualSymbols.has(symbol);

            // Remove from symbols array
            watchListState.symbols = watchListState.symbols.filter(s => s.symbol !== symbol);

            if (isManual) {
                // If it was manually added, remove from manual set
                watchListState.manualSymbols.delete(symbol);
                console.log(`Removed ${symbol} from manual symbols`);

                // Send DELETE request to backend API
                try {
                    const response = await fetch('cgi-bin/api/manual_symbols_api.py', {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ symbol: symbol })
                    });

                    const result = await response.json();

                    if (result.success) {
                        console.log(`‚úÖ Symbol ${symbol} removed from momentum_alerts.py monitoring`);
                    } else {
                        console.error(`‚ùå Failed to remove ${symbol} from backend:`, result.error);
                    }
                } catch (error) {
                    console.error(`‚ùå Error removing ${symbol} from backend:`, error);
                }
            } else {
                // If it came from API, add to deleted set to prevent it from showing up on auto-refresh
                watchListState.deletedSymbols.add(symbol);
                console.log(`Added ${symbol} to deleted symbols (will hide on auto-refresh)`);
            }

            // Re-render
            renderWatchList();

            console.log(`Deleted ${symbol} from watch list (manual: ${watchListState.manualSymbols.size}, deleted: ${watchListState.deletedSymbols.size})`);
        }

        // ========================================
        // SCANNER FUNCTIONALITY
        // ========================================

        // Scanner state
        const scannerState = {
            alerts: [],
            refreshInterval: null,
            resizing: {
                isResizing: false,
                currentColumn: null,
                startX: 0,
                startWidth: 0
            }
        };

        // Initialize scanner on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadScanner();
            // Refresh scanner every 5 seconds
            scannerState.refreshInterval = setInterval(loadScanner, 5000);
            // Initialize column resizing
            initScannerColumnResize();
        });

        // Load scanner alerts from API
        async function loadScanner() {
            try {
                console.log('Loading scanner alerts from API...');
                const response = await fetch('cgi-bin/api/scanner_api.py');
                console.log('Scanner API response status:', response.status);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Scanner data received:', data);

                if (data.success) {
                    scannerState.alerts = data.data;
                    console.log(`Loaded ${scannerState.alerts.length} momentum alerts`);
                    renderScanner();
                } else {
                    console.error('Failed to load scanner:', data.error);
                    showScannerError(`Failed to load scanner: ${data.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error loading scanner:', error);
                showScannerError(`Error loading scanner: ${error.message}`);
            }
        }

        // Render scanner table
        function renderScanner() {
            const tbody = document.getElementById('scannerBody');

            if (!scannerState.alerts || scannerState.alerts.length === 0) {
                tbody.innerHTML = `
                    <tr class="scanner-empty">
                        <td colspan="6">No momentum alerts</td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = scannerState.alerts.map(alert => {
                // Format gain with + sign for positive values
                const gainStr = alert.gain >= 0 ? `+${alert.gain.toFixed(2)}%` : `${alert.gain.toFixed(2)}%`;
                const gainClass = alert.gain >= 0 ? 'positive' : 'negative';

                // Format volume with commas
                const volumeStr = alert.volume.toLocaleString();

                return `
                    <tr ondblclick="openChartFromScanner('${alert.symbol}')">
                        <td class="symbol-cell">${alert.symbol}</td>
                        <td class="source-cell">${alert.source}</td>
                        <td class="time-cell">${alert.time}</td>
                        <td class="gain-cell ${gainClass}">${gainStr}</td>
                        <td class="volume-cell">${volumeStr}</td>
                        <td class="text-cell">${alert.text}</td>
                    </tr>
                `;
            }).join('');
        }

        // Show scanner error
        function showScannerError(message) {
            const tbody = document.getElementById('scannerBody');
            tbody.innerHTML = `
                <tr class="scanner-empty">
                    <td colspan="6" style="color: var(--accent-red);">${message}</td>
                </tr>
            `;
        }

        // Open chart from scanner (double-click)
        function openChartFromScanner(symbol) {
            if (!symbol) return;

            console.log(`Opening chart for ${symbol} from scanner`);

            // Set search input value
            const searchInput = document.getElementById('symbolSearch');
            if (searchInput) {
                searchInput.value = symbol.toUpperCase();
            }

            // Open chart
            handleSearch();
        }

        // Initialize scanner column resizing
        function initScannerColumnResize() {
            const table = document.querySelector('.scanner-table');
            if (!table) return;

            const headers = table.querySelectorAll('th');

            headers.forEach((header, index) => {
                const resizeHandle = header.querySelector('.resize-handle');
                if (!resizeHandle) return;

                resizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    scannerState.resizing.isResizing = true;
                    scannerState.resizing.currentColumn = header;
                    scannerState.resizing.startX = e.pageX;
                    scannerState.resizing.startWidth = header.offsetWidth;

                    header.classList.add('resizing');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                });
            });

            // Global mouse move handler
            document.addEventListener('mousemove', (e) => {
                if (!scannerState.resizing.isResizing) return;

                const diff = e.pageX - scannerState.resizing.startX;
                const newWidth = scannerState.resizing.startWidth + diff;

                // Set minimum width of 50px
                if (newWidth >= 50) {
                    scannerState.resizing.currentColumn.style.width = newWidth + 'px';
                    scannerState.resizing.currentColumn.style.minWidth = newWidth + 'px';
                }
            });

            // Global mouse up handler
            document.addEventListener('mouseup', () => {
                if (scannerState.resizing.isResizing) {
                    scannerState.resizing.isResizing = false;
                    if (scannerState.resizing.currentColumn) {
                        scannerState.resizing.currentColumn.classList.remove('resizing');
                    }
                    scannerState.resizing.currentColumn = null;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

    </script>
</body>
</html>
