#!/home/wilsonb/miniconda3/envs/alpaca/bin/python
"""
Momentum Alerts API Endpoint

Provides REST API for retrieving recent momentum alerts for web interface display.
This endpoint reads alert JSON files generated by momentum_alerts.py and returns
alerts that haven't been displayed yet.

Usage:
    GET /api/momentum_alerts - Returns recent momentum alerts

Query Parameters:
    - since: ISO timestamp - only return alerts after this time (optional)
    - limit: integer - maximum number of alerts to return (default: 50)

GoDaddy CGI compatible.
"""

import json
import os
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List

# Add project root to path for imports
# Resolve symlinks to get the actual repository path
script_path = Path(__file__).resolve()
project_root = script_path.parent.parent.parent
sys.path.insert(0, str(project_root))

import pytz


def get_query_params() -> Dict[str, str]:
    """
    Parse CGI query parameters from QUERY_STRING environment variable.

    Returns:
        Dictionary of query parameters
    """
    params = {}
    query_string = os.environ.get('QUERY_STRING', '')

    if query_string:
        for param in query_string.split('&'):
            if '=' in param:
                key, value = param.split('=', 1)
                params[key] = value

    return params


def get_recent_momentum_alerts(since_timestamp: str = None, limit: int = 50) -> List[Dict]:
    """
    Load recent momentum alerts from JSON files.

    Args:
        since_timestamp: ISO timestamp - only return alerts after this time
        limit: Maximum number of alerts to return

    Returns:
        List of alert dictionaries sorted by timestamp (newest first)
    """
    et_tz = pytz.timezone('US/Eastern')
    today = datetime.now(et_tz).strftime('%Y-%m-%d')

    # Path to momentum alerts SENT directory (alerts that were actually sent to users)
    alerts_dir = Path(project_root) / "historical_data" / today / "momentum_alerts_sent" / "bullish"

    if not alerts_dir.exists():
        print(f"Alerts directory not found: {alerts_dir}", file=sys.stderr)
        return []

    # Parse since_timestamp if provided
    since_dt = None
    if since_timestamp:
        try:
            # Try parsing ISO format
            since_dt = datetime.fromisoformat(since_timestamp.replace('Z', '+00:00'))
            if since_dt.tzinfo is None:
                since_dt = et_tz.localize(since_dt)
            else:
                since_dt = since_dt.astimezone(et_tz)
            print(f"Filtering alerts since: {since_dt}", file=sys.stderr)
        except Exception as e:
            print(f"Error parsing since_timestamp: {e}", file=sys.stderr)

    # Load all alert JSON files
    alerts = []
    try:
        alert_files = sorted(alerts_dir.glob('alert_*.json'), reverse=True)  # Newest first

        for alert_file in alert_files[:limit * 2]:  # Read up to 2x limit for filtering
            try:
                with open(alert_file, 'r') as f:
                    alert_data = json.load(f)

                # Parse alert timestamp
                alert_timestamp = datetime.fromisoformat(alert_data['timestamp'])
                if alert_timestamp.tzinfo is None:
                    alert_timestamp = et_tz.localize(alert_timestamp)
                else:
                    alert_timestamp = alert_timestamp.astimezone(et_tz)

                # Filter by since_timestamp if provided
                if since_dt and alert_timestamp <= since_dt:
                    continue

                # Add filename for tracking
                alert_data['alert_id'] = alert_file.stem
                alert_data['alert_file'] = alert_file.name

                alerts.append(alert_data)

                # Stop if we have enough alerts
                if len(alerts) >= limit:
                    break

            except Exception as e:
                print(f"Error reading alert file {alert_file}: {e}", file=sys.stderr)
                continue

        print(f"Loaded {len(alerts)} alerts from {alerts_dir}", file=sys.stderr)

    except Exception as e:
        print(f"Error loading alerts: {e}", file=sys.stderr)

    return alerts


def format_alert_for_display(alert: Dict) -> Dict:
    """
    Format alert data for web interface display.

    Args:
        alert: Alert dictionary from JSON file

    Returns:
        Formatted alert dictionary optimized for display
    """
    # Format the display data
    display_data = {
        'id': alert.get('alert_id'),
        'symbol': alert.get('symbol'),
        'timestamp': alert.get('timestamp'),
        'current_price': alert.get('current_price'),
        'market_open_price': alert.get('market_open_price'),
        'percent_gain_since_market_open': alert.get('percent_gain_since_market_open'),
        'vwap': alert.get('vwap'),
        'ema_9': alert.get('ema_9'),
        'momentum': alert.get('momentum'),
        'momentum_short': alert.get('momentum_short'),
        'momentum_squeeze': alert.get('momentum_squeeze'),
        'momentum_emoji': alert.get('momentum_emoji'),
        'momentum_short_emoji': alert.get('momentum_short_emoji'),
        'squeeze_emoji': alert.get('squeeze_emoji'),
        'halt_emoji': alert.get('halt_emoji'),
        'volume_emoji': alert.get('volume_emoji'),
        'current_volume': alert.get('current_volume'),
        'urgency': alert.get('urgency'),
        'is_halted': alert.get('is_halted'),
        'volume_surge_detected': alert.get('volume_surge_detected'),
        'volume_surge_ratio': alert.get('volume_surge_ratio'),
        'float_rotation': alert.get('float_rotation'),
        'float_rotation_percent': alert.get('float_rotation_percent'),
        'shares_outstanding': alert.get('shares_outstanding'),
        'float_shares': alert.get('float_shares'),
        'market_cap': alert.get('market_cap'),
        'from_gainers': alert.get('from_gainers'),
        'from_volume_surge': alert.get('from_volume_surge'),
        'oracle': alert.get('oracle')
    }

    return display_data


def main():
    """Main CGI entry point."""
    # Parse query parameters
    params = get_query_params()
    since_timestamp = params.get('since')
    limit = int(params.get('limit', 50))

    # Get recent alerts
    alerts = get_recent_momentum_alerts(since_timestamp=since_timestamp, limit=limit)

    # Format alerts for display
    formatted_alerts = [format_alert_for_display(alert) for alert in alerts]

    # Build response
    response = {
        'success': True,
        'data': formatted_alerts,
        'count': len(formatted_alerts),
        'timestamp': datetime.now(pytz.timezone('US/Eastern')).isoformat()
    }

    # Output CGI headers
    print("Content-Type: application/json")
    print("Access-Control-Allow-Origin: *")
    print()

    # Output JSON response
    print(json.dumps(response, indent=2))


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        # Error response
        error_response = {
            'success': False,
            'error': str(e),
            'timestamp': datetime.now(pytz.timezone('US/Eastern')).isoformat()
        }

        print("Content-Type: application/json")
        print("Access-Control-Allow-Origin: *")
        print()
        print(json.dumps(error_response, indent=2))

        # Log error to stderr
        import traceback
        print(traceback.format_exc(), file=sys.stderr)
